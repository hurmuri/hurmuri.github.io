<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[货币格式化函数]]></title>
    <url>%2F2017%2F09%2F22%2F%E8%B4%A7%E5%B8%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[保留两位小数12345678910111213141516//货币格式化 function formatCurrency(num) &#123; num = num.toString().replace(/\$|\,/g, '') if (isNaN(num)) num = "0" sign = (num == (num = Math.abs(num))) num = Math.floor(num * 100 + 0.50000000001) cents = num % 100 num = Math.floor(num / 100).toString() if (cents &lt; 10) cents = "0" + cents for (var i = 0; i &lt; Math.floor((num.length - (1 + i)) / 3); i++) num = num.substring(0, num.length - (4 * i + 3)) + ',' + num.substring(num.length - (4 * i + 3)) return (((sign) ? '' : '-') + num + '.' + cents) &#125; 保留一位小数1234567891011121314 //货币格式化 function formatCurrencyTenThou(num) &#123; num = num.toString().replace(/\$|\,/g,''); if(isNaN(num)) num = "0"; sign = (num == (num = Math.abs(num))); num = Math.floor(num*10+0.50000000001); cents = num%10; num = Math.floor(num/10).toString(); for (var i = 0; i &lt; Math.floor((num.length-(1+i))/3); i++) num = num.substring(0,num.length-(4*i+3))+','+ num.substring(num.length-(4*i+3)); return (((sign)?'':'-') + num + '.' + cents);&#125; 不保留小数123456function formatPrice(n) &#123; var t = parseInt(n), i, r; for (t = t.toString().replace(/^(\d*)$/, "$1."), t = (t + "00").replace(/(\d*\.\d\d)\d*/, "$1"), t = t.replace(".", ","), i = /(\d)(\d&#123;3&#125;,)/; i.test(t); ) t = t.replace(i, "$1,$2"); return t = t.replace(/,(\d\d)$/, ".$1"), r = t.split("."), r[1] == "00" &amp;&amp; (t = r[0]), t &#125;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鼠标滚轮事件兼容写法]]></title>
    <url>%2F2017%2F09%2F20%2F%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%E5%85%BC%E5%AE%B9%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[鼠标滚轮兼容写法：12345678910111213141516171819202122232425262728293031323334353637383940414243//鼠标滚轮兼容写法var addMouseWheelHandler = function()&#123; if (document.addEventListener) &#123; document.addEventListener('mousewheel', MouseWheelHandler, false); //IE9, Chrome, Safari, Oper document.addEventListener('wheel', MouseWheelHandler, false); //Firefox document.addEventListener('DOMMouseScroll', MouseWheelHandler, false); //Old Firefox &#125; else &#123; document.attachEvent('onmousewheel', MouseWheelHandler); //IE 6/7/8 &#125; &#125;, removeMouseWheelHandler = function()&#123; if (document.addEventListener) &#123; document.removeEventListener('mousewheel', MouseWheelHandler, false); //IE9, Chrome, Safari, Oper document.removeEventListener('wheel', MouseWheelHandler, false); //Firefox document.removeEventListener('DOMMouseScroll', MouseWheelHandler, false); //old Firefox &#125; else &#123; document.detachEvent('onmousewheel', MouseWheelHandler); //IE 6/7/8 &#125; &#125;, stopDefault = function(e) &#123; //W3C if ( e &amp;&amp; e.preventDefault ) e.preventDefault(); //IE else window.event.returnValue = false; return false; &#125;, MouseWheelHandler = function(e) &#123;//滚动后的处理函数 stopDefault(e); var e = e || window.event, value = e.wheelDelta || -e.deltaY || -e.detail, delta = Math.max(-1, Math.min(1, value)); if (delta &lt; 0) &#123;//scrolling down console.log("下滑") &#125;else &#123;//scrolling up console.log("上滑") &#125; &#125;; //调用 addMouseWheelHandler();]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重+排序]]></title>
    <url>%2F2017%2F09%2F12%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2B%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[方案一（仅去重）：123456var rusultArr=newArr.reduce(function(rusultArr,a)&#123; if(rusultArr.indexOf(a)==-1)&#123; rusultArr.push(a) &#125;return rusultArr&#125;,[]) 方案二（去重加排序）：1rusultArr=Array.from(new Set(newArr)).sort(function(a,b)&#123;return a-b&#125;)]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决代码太长的问题]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%8F%82%E6%95%B0%E4%BB%A3%E7%A0%81%E5%A4%AA%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决代码太长的问题 利用+连接字符串 12345678var func = new Function( 'a', 'b', 'c', 'var res = a &gt; b ? a : b;' + 'res = res &gt; c ? res : c;' + 'return res;' ); 利用字符串特性 1234567function foo ( a, b, c ) &#123; var res = a &gt; b ? a : b; res = res &gt; c ? res : c; return res;&#125;var func = new Function( 'a', 'b', 'c', 'return foo( a, b, c );'); ES6 语法（很少有浏览器实现）使用键盘左上角的` 表示可换行字符串的界定符，之前我们用的是单引号或者双引号来表示一个字符串字面量，在ES6中可以用反引号来表示该字符串可换行。 (最终)利用 DOM 的特性完成该方法 1234567891011121314&lt;div id="code" style="display:none"&gt;var res = a &gt; b ? a : b;res = res &gt; c ? res : c;return res;&lt;/div&gt;&lt;script&gt;var txt = document.getElementbyId("code).innerHtml + ' ';var func = new Function('a', 'b', 'c', txt);&lt;/script&gt;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝和浅拷贝]]></title>
    <url>%2F2016%2F12%2F12%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[1. 浅拷贝和深拷贝的概念1.1. 什么是浅拷贝？如果拷贝的时候，只针对当前对象的属性进行拷贝，而不考虑引用类型的属性，那么这个就是浅拷贝 比如下面这个对象： 1234567891011var p = &#123; name:"张三", age:18, car:&#123; name:"Ferrari" &#125;&#125;;/* 浅拷贝的代码*///经过深拷贝之后，我们得到一个p对象深拷贝的副本 pCopy 浅拷贝之后，内存中的存储情况： 1.2. 什么是深拷贝？如果拷贝的时候，将数据所有的引用结构都拷贝一份，拷贝所得的数据在内存中是完全独立的，那么这个就是深拷贝 比如下面这个对象： 12345678910111213var p = &#123; name:"张三", age:18, car:&#123; name:"Ferrari" &#125;&#125;;/* 深拷贝的代码*///经过深拷贝之后，我们得到一个p对象深拷贝的副本 pCopy 深拷贝之后，内存中的存储情况： 2. 浅拷贝和深拷贝的代码实现浅拷贝代码实现： 12345678910111213var p = &#123; name:"张三", age:18, car:&#123; name:"Ferrari" &#125;&#125;//对p对象进行浅拷贝var pCopy = &#123;&#125;;pCopy.name = p.name;pCopy.age = p.age;pCopy.car = p.car; 深拷贝代码实现： 12345678910111213var p = &#123; name:"张三", age:18, car:&#123; name:"Ferrari" &#125;&#125;var pCopy = &#123;&#125;;pCopy.name = p.name;pCopy.age = p.age;pCopy.car = &#123;&#125;;pCopy.car.name = p.car.name; 3. 浅拷贝和深拷贝代码封装浅拷贝封装： 123456789101112131415161718192021222324252627var p = &#123; name: '张三', age: 19, copy: function () &#123; // 将当前对象拷贝一份 // 1, 创建对象 var temp = &#123;&#125;; // 2, 复制属性. 在 copy 中使用 this 表示当前对象 for ( var k in this ) &#123; temp[ k ] = this[ k ]; &#125; // 3, 返回对象 return temp; &#125;&#125;;var p2 = p.copy();p.name = '李四';p.age = 20;p.gender = '女';var o = &#123;&#125;;o.func = p.copy;o.func(); 深拷贝封装： 12345678910111213141516171819202122232425262728293031323334353637383940414243var car = &#123; name: '法拉利', deepCopy: function() &#123; // 1, 创建一个对象 var temp = &#123;&#125;; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) &#123; if ( typeof this[ k ] === 'object' ) &#123; temp[ k ] = this[ k ].deepCopy(); &#125; else &#123; temp[ k ] = this[ k ]; &#125; &#125; // 3, 返回对象 return temp; &#125;&#125;;var p = &#123; name: '张三', car: car, deepCopy: function () &#123; // 1, 创建一个对象 var temp = &#123;&#125;; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) &#123; if ( typeof this[ k ] === 'object' ) &#123; temp[ k ] = this[ k ].deepCopy(); &#125; else &#123; temp[ k ] = this[ k ]; &#125; &#125; // 3, 返回对象 return temp; &#125;&#125; 如果可以保证所有的对象中都有copy方法，那么就可以简化了 写一个deepCopy函数, 每一个对象都使用对象.deepCopy = deepCopy使得当前对象具有拷贝的方法, 那么就可以实现深拷贝了 深拷贝最终版本： 123456789101112131415161718192021222324252627282930var deepCopy = function () &#123; // 1, 创建一个对象 var temp = &#123;&#125;; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) &#123; if ( typeof this[ k ] === 'object' ) &#123; temp[ k ] = this[ k ].deepCopy(); &#125; else &#123; temp[ k ] = this[ k ]; &#125; // temp[ k ] = this[ k ]; &#125; // 3, 返回对象 return temp;&#125;var car = &#123; name: '法拉利' &#125;;var p = &#123; name: '张三', age: 19, gender: '男', car: car &#125;;// 让所有的对象都有 拷贝的 方法car.deepCopy = deepCopy;p.deepCopy = deepCopy;var newP = p.deepCopy();p.name = '李四';p.age = 20;p.gender = '女';p.car.name = '兰博基尼';]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性搜索原则]]></title>
    <url>%2F2016%2F11%2F08%2F%E5%B1%9E%E6%80%A7%E6%90%9C%E7%B4%A2%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[属性搜索原则访问一个对象的成员的时候，首先是在实例中找，没有找到, 就去原型中找, 但是原型中没有怎么办? 原型链每一个对象都有原型属性，那么对象的原型属性也会有原型属性，所以这样就形成了一个链式结构，我们称之为原型链。 属性搜索原则所谓的属性搜索原则，也就是属性的查找顺序，在访问对象的成员的时候，会遵循如下的原则: 首先在当前对象中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步 在该对象的原型中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步 在该对象的原型的原型中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步。 继续往上查找，直到查找到Object.prototype还没有, 那么是属性就返回 undefied，是方法，就报错xxx is not a function。]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F2016%2F11%2F05%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[常见的异常分类 运行环境的多样性导致的异常（浏览器） 语法错误，代码错误 异常最大的特征，就是一旦代码出现异常，后面的代码就不会再执行 异常捕获捕获异常，使用try-catch语句123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为： 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中 catch中处理错误信息 然后继续执行后面的代码 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码 通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。 注意： 语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。 try-catch在一般日常开发中基本用不到，但是如果要写框架什么的，用的会非常多。因为这个会让框架变得健壮 抛出异常如何手动的抛出异常呢？ 案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。 抛出异常使用throw关键字，语法如下：1throw 异常对象; 异常对象一般是用new Error(&quot;异常消息&quot;), 也可以使用任意对象 12345678910111213function test(para)&#123; if(para == undefined)&#123; throw new Error("请传递参数"); //这里也可以使用自定义的对象 throw &#123;"id":1, msg:"参数未传递"&#125;; &#125;&#125;try&#123; test();&#125;catch(e)&#123; console.log(e);&#125; 异常的传递机制123456789101112function f1 () &#123; f2(); // f1 称为调用者, 或主调函数, f2 称为被调用者, 或被调函数&#125;function f2 () &#123; f3();&#125;function f3() &#123; throw new Error( 'error' );&#125;f1(); 当在被调函数内发生异常的时候，异常会一级一级往上抛出。 异常捕获语句的完整模式异常捕获语句的完整模式为try-catch-finally 1234567try &#123; //可能出现错误的代码&#125; catch ( e ) &#123; //如果出现错误就执行&#125; finally &#123; //结束 try 这个代码块之前执行, 即最后执行&#125; finally中的代码，不管有没有发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态成员与实例成员的概念]]></title>
    <url>%2F2016%2F10%2F30%2F%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[静态成员与实例成员的概念静态成员和实例成员这两个概念其实也是从面相对象的编程语言中引入的，对应到JavaScript中的理解为： 静态成员静态成员是指静态属性和静态方法，所谓静态，就是有构造函数提供的。 实例成员实例成员是值实例属性和实例方法，所谓实例，就是由构造函数创建出来的对象。 举例说明：1234567891011121314151617181920212223function Person()&#123; this.name = "zs", this.sayHello = function()&#123; console.log("Hello World"); &#125;&#125;//下面这个sayHi方法就是构造函数自己的方法，也就是静态方法Person.sayHi = function()&#123; console.log("I'm a Person");&#125;//原型属性属于构造函数，所以原型属性是静态属性Person.prototype = &#123;&#125;;var p = new Person();//这里的name是构造函数创建出来的实例对象的属性，所以是实例属性p.name = "李四";//这里的sayHello也是构造函数创建出来的实例对象的方法，所以是实例方法p.sayHello(); 提示：一般工具型方法都有静态成员提供, 一般与实例对象有关的方法由实例成员表示. 工具方法：比如jQuery.Ajax()、jQuery.trim()、jQuery.Each()]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的动态特性]]></title>
    <url>%2F2016%2F10%2F15%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1、给对象动态添加属性当一个对象需要某个属性的时候，可以用两种方式为其添加属性 直接使用对象名.属性名 = 值这种形式，为对象添加对应的属性。 使用关联数组语法对象名[&quot;属性名&quot;] = 值这种形式，为对象添加对应的属性 12345678910//o是一个没有任何自定义属性的对象var o = &#123;&#125;;//现在想让他拥有name age gender等属性//直接使用 对象名.属性名 = 值o.name = "张三";//使用 对象名["属性名"] = 值o["age"] = 18;//可以通过打印查看效果console.log(o.name);console.log(o.age); 注意： 当要动态的为一个对象添加属性的时候，必须使用关联数组的方式。 1234567//接收到了用户的输入var str = prompt("请输入属性名");o = &#123;&#125;;//o.str = "这是一个新属性"; //这么写是不对的，会给对象新增一个str属性//正确的写法如下o[str]="这是一个新属性"; 2、对象属性的访问形式 点语法：对象名.属性名 关联数组：对象名[属性名] 12345678910111213141516171819202122232425var o = &#123; name:"张三", sayHello:function()&#123; console.log("你好，我叫"+ this.name); &#125;&#125;;//点语法console.log(o.name);//关联数组语法console.log(o["name"]);//这两种用法同样适用于方法o.sayHello();o["sayHello"]();//可以对这个对象的属性进行遍历，如果是值就打印，如果是方法就调用for(var k in o)&#123; if ( typeof o[ k ] == 'function' ) &#123; o[ k ](); &#125; else &#123; console.log( 'log: ' + o[ k ] ); &#125;&#125;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程举例]]></title>
    <url>%2F2016%2F10%2F10%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%BE%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[面向对象编程举例 创建一个 div 标签, 并设置其样式, 加入页面中 传统的处理办法1234567891011//1. 首先找对象//2. 任何操作应该交给对象完成// 任务需求:// 1&gt; 创建一个 div 标签var div = document.createElement( 'div' );// 2&gt; 将 div 加到页面中document.body.appendChild( div );// 3&gt; 设置 div 的样式div.style.border = '1px dashed red';div.style.width = '400px';div.style.height = '300px'; 使用面向对象的方式12345678910111213141516171819202122232425// 面向对象的方式去思考:// 1, 抽取对象( 名词提炼法 ): div, body// 2, 分析属性与方法( 动词提炼 ): 加到, 设置样式var divTag = new DivTag(); // 内部应该创建 dom 对象// 构造函数内部应该创建 dom 对象 div, 同时将其设置为属性// 需要一个 div 的构造函数function DivTag() &#123; this.DOM = document.createElement( 'div' ); this.__加到 = function ( node ) &#123; // 需要将 this.DOM 加到 node 中 node.appendChild( this.DOM ); &#125;; this.__设置样式 = function ( name, value ) &#123; // 设置 this.DOM 的样式 this.DOM.style[ name ] = value; &#125;;&#125;var divTag = new DivTag();divTag.__设置样式( 'border', '1px solid red' );divTag.__设置样式( 'width', '400px' );divTag.__设置样式( 'height', '100px' );divTag.__设置样式( 'backgroundColor', 'pink' );]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的基本概念]]></title>
    <url>%2F2016%2F10%2F08%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1.什么是面向对象编程？ 2.面向过程和面向对象的对比Example 1：洗衣服 12345678910111213面向过程的思维方式： step 1:收拾脏衣服 step 2:打开洗衣机盖 step 3:将脏衣服放进去 step 4:设定洗衣程序 step 5:开始洗衣服 step 6:打开洗衣机盖子 step 7:晒衣服面向对象的思维方式： 洗衣机需要什么对象？ 女朋友 洗衣机 在面向对象的思维方式中：我们只关心要完成事情需要的对象。 总结：面向对象是一种解决问题的思路，一种编程思想。 对象是什么呢？万物皆对象 JavaScript中的对象是什么？在JavaScript中，所谓的对象，就是键值对的集合。 比如要描述一个人，这个人有name,age,gender,体现在代码中：1&#123; name:"张三", age:18, gender:"Male" &#125; 比如要做一个学生管理系统，那学生就是要设计的对象，学生拥有name,age,gender,address,phone,体现在代码中： 1&#123; name:"刘亦菲", age:18, gender:"female", address:"上海", phone:"110" &#125; 3.总结 面向过程关注的实现功能的步骤，是如何把功能拆解后一步步的实现 面向对象则是关注的实现功能的一系列的对象]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域链]]></title>
    <url>%2F2016%2F10%2F03%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[作用域链什么是作用域链只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。 凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 例如： 12345678910function f1() &#123; function f2() &#123; &#125;&#125;var num = 456;function f3() &#123; function f4() &#123; &#125;&#125; 绘制作用域链的步骤: 看整个全局是一条链, 即顶级链, 记为 0 级链 看全局作用域中, 有什么成员声明, 就以方格的形式绘制到 0 级练上 再找函数, 只有函数可以限制作用域, 因此从函数中引入新链, 标记为 1 级链 然后在每一个 1 级链中再次往复刚才的行为 变量的访问规则 首先看变量在第几条链上, 在该链上看是否有变量的定义与赋值, 如果有直接使用 如果没有到上一级链上找( n - 1 级链 ), 如果有直接用, 停止继续查找. 如果还没有再次往上刚找… 直到全局链( 0 级 ), 还没有就是 is not defined 注意,同级的链不可混合查找 练习：绘制作用域链12345678910function f1() &#123; var num = 123; function f2() &#123; console.log( num ); &#125; f2();&#125;var num = 456;f1(); 如何分析代码 在分析代码的时候切记从代码的运行进度上来分析, 如果代码给变量赋值了, 一定要标记到图中 如果代码比较复杂, 可以在图中描述代码的内容, 有事甚至需要将原型图与作用域图合并分析 练习12345678910var num = 123;function f1() &#123; console.log( num );&#125;function f2() &#123; var num = 456; f1();&#125;f2(); 练习12345678910111213var num = 123;function f1() &#123; console.log( num );&#125;function f2() &#123; num = 456; f1();&#125;f2(); 补充 声明变量使用var, 如果不使用var声明的变量就是全局变量( 禁用 ) 因为在任何代码结构中都可以使用该语法. 那么再代码维护的时候会有问题. 所以除非特殊原因不要这么用. 下面的代码的错误 12345function foo () &#123; var i1 = 1 // 局部 i2 = 2, // 全局 i3 = 3; // 全局&#125; 此时注意 1234567891011121314151617181920var arr = [];for ( var i = 0; i &lt; 10; i++ ) &#123; arr.push( i );&#125;for ( var i = 0; i &lt; 10; i++ ) &#123; console.log( arr[ i ] );&#125;// 一般都是将变量的声明全部放到开始的位置, 避免出现因为提升而造成的错误var arr = [],i = 0;for ( ; i &lt; 10; i++ ) &#123; arr.push( i );&#125;for ( i = 0; i &lt; 10; i++ ) &#123; console.log( arr[ i ] );&#125;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域]]></title>
    <url>%2F2016%2F10%2F02%2F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域域，表示的是一个范围，作用域，就是作用范围。 作用域说明的是一个变量可以在什么地方被使用，什么地方不能被使用。 块级作用域JavaScript中没有块级作用域 1234567&#123; var num = 123; &#123; console.log( num ); &#125;&#125;console.log( num ); 上面这段代码在JavaScript中是不会报错的，但是在其他的编程语言中（C#、C、JAVA）会报错。 这是因为，在JavaScript中没有块级作用域，使用{}标记出来的代码块中声明的变量num，是可以被{}外面访问到的。 但是在其他的编程语言中，有块级作用域，那么{}中声明的变量num，是不能在代码块外部访问的，所以报错。 词法作用域什么是词法作用域？ 词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域. 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 例子1：123456789var num = 123;function foo() &#123; console.log( num );&#125;foo(); 例子2：1234if ( false ) &#123; var num = 123;&#125;console.log( num ); // undefiend 例子3：1234567891011var num = 123;function foo() &#123; var num = 456; function func() &#123; console.log( num ); &#125; func();&#125;foo(); 练习：1234567891011121314var num1 = 123;function foo1() &#123; var num1 = 456; function foo2() &#123; num1 = 789; function foo3 () &#123; console.log( num1 ); &#125; foo3(); &#125; foo2();&#125;foo1();console.log( num1 );]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传统构造函数存在的问题]]></title>
    <url>%2F2016%2F10%2F02%2F%E4%BC%A0%E7%BB%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 发现问题现有构造函数如下： 1234567function Person(name, age)&#123; this.name = name; this.age = age; this.sayHi = function()&#123; console.log("你好"); &#125;&#125; 调用该构造函数创建对象，并对比创建出来的对象的sayHi方法：1234var p = new Person("张三", 18);var p1 = new Person("李四", 19);console.log(p.sayHi == p1.sayHi); //输出结果为false 由于每个对象都是由new Person创建出来的，因此每创建一个对象，函数sayHi都会被重新创建一次，这个时候，每个对象都拥有一个独立的，但是功能完全相同的方法。 功能相同的函数，完全没有必要再内存中存在这么多份。所以就造成了资源浪费。 2. 解决问题这里最好的办法就是将函数体放在构造函数之外. 在构造函数中只需要引用该函数即可。 1234567891011121314function sayHello()&#123; console.log("你好");&#125;function Person(name, age)&#123; this.name = name; this.age = age; this.sayHi = sayHello;&#125;//调用该构造函数创建对象，并对比创建出来的对象的sayHi方法var p = new Person("张三", 18);var p1 = new Person("李四", 19);console.log(p.sayHi == p1.sayHi); //输出结果为true 这样写依然存在问题： 全局变量增多，会增加引入框架命名冲突的风险 代码结构混乱，会变得难以维护]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数的作用]]></title>
    <url>%2F2016%2F09%2F22%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[构造函数的作用1234function Person(name, age)&#123; this.name = name; this.age = age;&#125; 123456//断点调试，进行类型查看var p1 = new Person();var p2 = new Object();var p3 = new Date();var p4 = new RegExp();var p5 = &#123;&#125;; 1.构造函数是干什么用的？在JavaScript中，构造函数是给对象添加属性，初始化属性用的。 2. 对象的创建过程1var p = new Person(); 以上面这个p对象创建为例： 首先使用new关键字创建对象，类似于使用{},这个时候创建出来的对象是一个”没有任何成员”的对象。这里需要注意两点： 使用new关键字创建的对象，对象的类型就是创建这个对象使用的构造函数的函数名 使用{}创建对象，对象的类型一定是Object，相当于使用了new Object() 使用构造函数为其初始化成员 在构造函数调用开始的时候，有一个赋值操作，也就是让this = 刚创建出来的对象 在构造函数中，this就代表刚创建出来的对象 在构造函数中，利用对象的动态特性，为对象添加成员]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数模式]]></title>
    <url>%2F2016%2F09%2F20%2F%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数模式特征:就是一个简单的函数调用，函数名前面没有任何的引导内容 123456function foo()&#123;&#125;var func = function()&#123;&#125;foo();func();(function()&#123;&#125;)(); this在函数模式中的含义：this在函数中表示全局对象，在浏览器中是window对象 方法模式特征: 方法一定是依附于一个对象, 将函数赋值给对象的一个属性, 那么就成为了方法. 1234567function f() &#123; this.method = function () &#123;&#125;;&#125;var o = &#123; method: function () &#123;&#125;&#125; this在方法模式调用中的含义:表示函数所依附的这个对象 构造器调用模式由于构造函数只是给 this 添加成员. 没有做其他事情. 而方法也可以完成这个操作, 就 this 而言, 构造函数与方法没有本质区别. 特征:使用 new 关键字, 来引导构造函数. 1234567function Person()&#123; this.name = "zhangsan"; this.age = 19; this.sayHello = function()&#123; &#125;;&#125;var p = new Person(); 构造函数中发this与方法中一样, 表示对象, 但是构造函数中的对象是刚刚创建出来的对象 关于构造函数中return关键字的补充说明 构造函数中不需要return, 就会默认的return this 如果手动的添加return, 就相当于 return this 如果手动的添加return 基本类型; 无效, 还是保留原来 返回this 如果手动添加return null; 或return undefiend, 无效 如果手动添加return 对象类型; 那么原来创建的this就会被丢掉, 返回的是 return后面的对象 创建对象的模式工厂方法123456789// 工厂就是用来生产的, 因此如果函数创建对象并返回, 就称该函数为工厂函数function createPerson( name, age, gender ) &#123; var o = &#123;&#125;; o.name = name; o.age = age; o.gender = gender; return o;&#125;// document.createElement() 构造方法1234567function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender;&#125;var p = new Person("zhangsan", 19, "男"); 寄生式创建对象12345678910function Person(name, age, gender)&#123; var o = &#123;&#125;; o.name = name; o.age = age; o.gender = gender; return o;&#125;var p = new Person("Jack", 18, "male"); 混合式创建混合式继承就是讲所有的属性放在构造方法里面，然后讲所有的方法放在原型里面，使用构造方法和原型配合起来创建对象。 上下文调用模式上下文(Context)，就是函数调用所处的环境。 上下文调用，也就是自定义设置this的含义。 在其他三种调用模式中，函数/方法在调用的时候，this的值都是指定好了的，我们没办法自己进行设置，如果尝试去给this赋值，会报错。 上下文调用的语法12345678910//第一种， apply函数名.apply(对象, [参数]);//第二种， call函数名.call(对象, 参数);//上面两种方式的功能一模一样，只是在传递参数的时候有差异。 功能描述： 语法中的函数名表示的就是函数本身，使用函数调用模式的时候，this默认是全局对象 语法中的函数名也可以是方法(如:obj.method)，在使用方法模式调用的时候，this默认是指当前对象 在使用apply和call的时候，默认的this都会失效，this的值由apply和call的第一个参数决定 补充说明 如果函数或方法中没有this的操作, 那么无论什么调用其实都一样. 如果是函数调用foo(), 那么有点像foo.apply( window ). 如果是方法调用o.method(), 那么有点像o.method.apply( o ). 参数问题call和apply在没有后面的参数的情况下(函数无参数, 方法无参数) 是完全一样的. 如下： 123456789101112function foo() &#123; console.log( this );&#125;foo.apply( obj );foo.call( obj ); 第一个参数的使用规则: 如果传入的是一个对象, 那么就相当于设置该函数中的 this 为参数 如果不传入参数, 或传入 null. undefiend 等, 那么相当于 this 默认为 window 12345678foo();foo.apply();foo.apply( null );foo.call( undefined ); 如果传入的是基本类型, 那么 this 就是基本类型对应的包装类型的引用 number -&gt; Number boolean -&gt; Boolean string -&gt; String 第二个参数的使用规则 在使用上下文调用的时候, 原函数(方法)可能会带有参数, 那么这个参数在上下文调用中使用第二个( 第 n 个 )参数来表示 123456789101112function foo( num ) &#123; console.log( num );&#125;foo.apply( null, [ 123 ] );// 等价于foo( 123 ); 上下文调用模式的应用上下文调用只是能修改this, 但是使用的最多的地方上是函数借用. 1. 将伪数组转换为数组传统的做法：1234567891011var a = &#123;&#125;;a[ 0 ] = 'a';a[ 1 ] = 'b';a.length = 2;// 使用数组自带的方法 concat// 如果参数中有数组会把参数数组展开// 语法: arr.concat( 1, 2, 3, [ 4, [ 5 ] ] );// 特点：不修改原数组var arr = [];var newArr = arr.concat( a ); 由于a是伪数组, 只是长得像数组. 所以上面的代码不能成功，不能使用concat方法。 但是apply方法有一个特性, 可以将数组或伪数组作为参数。（IE8不支持伪数组操作） 1foo.apply( obj, 伪数组 ); // IE8 不支持 利用apply方法，可以写出以下12//将伪数组 a 作为 apply 的第二个参数var newArr = Array.prototype.concat.apply( [], a ) 处理数组转换, 实际上就是将元素一个一个的取出来构成一个新数组, 凡是涉及到该操作的方法理论上都可以。 push方法1234567891011121314//用法:arr.push( 1 ); //将这个元素加到数组中, 并返回所加元素的个数arr.push( 1, 2, 3 ); //将这三个元素依次加到数组中, 返回所加个数var a = &#123; length: 0 &#125;; // 伪数组a[ a.length++ ] = 'abc'; // a[ 0 ] = 'abc'; a.length++;a[ a.length++ ] = 'def';// 使用一个空数组, 将元素一个个放到数组中即可var arr = [];arr.push( a ); // 此时不会将元素展开, 而是将这个伪数组作为一个元素加到数组中// 再次利用 apply 可以展开伪数组的特征arr.push.apply( arr, a );// 利用 apply 可以展开伪数组的特性, 这里就相当于 arr.push( a[0], a[1] ) 2. 求数组中的最大值传统的做法 123456var max = arr[ 0 ];for ( var i = 1; i &lt; arr.length; i++ ) &#123; if ( arr[ i ] &gt; max ) &#123; ... &#125;&#125; 在 js 中的Math对象中提供了很多数学函数Math.max( 1,2,3 ) 还是利用 apply 可以展开数组的特性 12var arr = [ 123456,12345,1234,345345,234,5 ];Math.max.apply( null, arr ); 3.借用构造函数继承123456789101112function Person ( name, age, gender ) &#123; this.name = name; this.age = age; this.gender = gender;&#125;// 需要提供一个 Student 的构造函数创建学生对象// 学生也应该有 name, age, gender, 同时还需要有 course 课程function Student ( name, age, gender, course ) &#123; Person.call( this, name, age, gender ); this.course = course;&#125;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象/函数重复创建问题]]></title>
    <url>%2F2016%2F09%2F20%2F%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%9B%E5%BB%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 发现问题：首先分析如下代码： 12345var arr = [];for(var i = 0; i &lt; 10; i++)&#123; arr.push(&#123;&#125;);&#125;console.log(arr[0]==arr[1]); 由于每次循环都会使用{}创建一个新的对象，所以输出结果为false。 再分析如下代码： 1234567var arr = [];for(var i = 0; i &lt; 10; i++)&#123; arr.push(function()&#123; console.log("Hello JavaScript"); &#125;);&#125;console.log(arr[0]==arr[1]); 跟第一段代码相似，每次循环都会创建一个新的函数，所以输出结果为false。 函数的功能就是用来封装一段代码，方便再次调用。同样功能的函数本来只需要创建一份就可以方便到处调用，但是在上面第二段代码中，被创建了多次，这样就造成了资源浪费。 我们期望的是如下图所示的情况： 2. 解决方案可以对上面第二段代码进行如下改进： 12345678910111213//先定义该函数function printOut()&#123; console.log("Hello JavaScript");&#125;var arr = [];for(var i = 0; i &lt; 10; i++)&#123; //在循环中，不重新创建函数，而是将已经存在的函数拿过来直接使用 //也就是内存中只会有一份函数存在，每次push只是新增一个对该函数的引用而已 arr.push(printOut);&#125;console.log(arr[0]==arr[1]); 3.实际应用在实际开发当中，经常会有给多个元素注册同一个功能的时间处理函数的情况，如下： HTML代码1234567&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;&lt;div&gt;div3&lt;/div&gt;&lt;div&gt;div4&lt;/div&gt; JavaScript代码 12345678var divs = document.getElementsByTagName("div");for(var i = 0; i &lt; divs.length; i++)&#123; var div = divs[i]; div.addEventListener("click",function()&#123; div.firstChild.nodeValue = "我被点击了"; &#125;)&#125; 可以看到，上面用来注册事件代码的方式，会造成同一个功能的函数在内存中创建多个副本出来，这里暂时只有4个div，如果div的数量增加到100个，1000个，10000个，甚至1000000个呢？ 所以需要对上面的代码进行优化，优化的思路就是我们在上面提到的，首先创建一个处理函数，然后在循环中直接使用已经创建好的函数即可，这样内存中就只有一份函数代码存在了。 优化后的JavaScript代码 1234567891011function divClick()&#123; this.firstChild.nodeValue = "我被点击了";&#125;var divs = document.getElementsByTagName("div");for(var i = 0; i &lt; divs.length; i++)&#123; var div = divs[i]; div.addEventListener("click", divClick);&#125;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arguments对象]]></title>
    <url>%2F2016%2F09%2F15%2Farguments%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[arguments对象在每一个函数调用的过程中, 函数代码体内有一个默认的对象arguments, 它存储着实际传入的所有参数。 arguments是一个伪数组对象. 它表示在函数调用的过程中传入的所有参数的集合。在函数调用过程中不规定参数的个数与类型, 可以使得函数调用变得非常灵活性。 JavaScript中的函数并没有规定必须如何传参： 定义函数的时候不写参数, 一样可以调用时传递参数 定义的时候写了参数, 调用的时候可以不传参 定义的时候写了一个参数, 调用的时候可以随意的传递多个而参数 在代码设计中, 如果需要函数带有任意个参数的时候, 一般就不带任何参数, 所有的参数利用arguments对象来获取. 一般的函数定义语法, 可以写成: 12function foo ( /* ... */ ) &#123;&#125; 练习: 利用 Function 创建一个函数, 要求允许函数调用时传入任意个数参数, 并且函数返回这些数字中最大的数字. 123456789101112function foo ( ) &#123;// 所有的参数都在 arguments 中. 将其当做数组使用// 问题已转换成在有一个数组中求最大值var args = arguments;var max = args[ 0 ]; for ( var i = 1; i &lt; args.length; i++ ) &#123; if ( max &lt; args[ i ] ) &#123; max = args[ i ]; &#125; &#125; return max;&#125; 练习: 利用 Function 写一个函数, 要求传入任意个数字 求和]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function的使用]]></title>
    <url>%2F2016%2F09%2F11%2Ffunction%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Function 的使用语法:123456//Function函数所有的参数全都是字符串//Function函数的作用就是将所有的参数组合起来，变成一个函数//1、如果只传一个参数，那么这个函数必然是函数体//2、如果传多个参数，那么最后一个参数表示函数体，前面的参数代表将要创建的函数的参数//3、如果不传参数，表示创建一个空函数new Function(arg1, arg2, arg3, ..., argN, body); 创建一个打印一句话的函数1234567//传统的方式function foo()&#123; console.log("你好");&#125;//使用Functionvar func = new Function("console.log('你好');"); 这里两种方式创建出来的函数功能是一样的。 创建一个空函数12345//传统的方式function foo()&#123;&#125;//Functionvar func = new Function(); 创建一个有参数的函数12345678//传统的方式function foo(num)&#123; console.log(num);&#125;//Functionvar func = new Function()&#123;"num", "console.log(num);"&#125;; 练习: 利用 Function 创建一个函数, 要求传入两个数字, 打印其和12345var func = new Function( 'num1', 'num2', 'console.log( num1 + num2 );'); 练习: 利用 Function 创建一个函数, 要求允许函数调用时传入任意个数参数, 并且函数返回这些数字中最大的数字. 练习: 利用 Function 创建一个求三个数中最大数的函数.12345678910111213// 传统function foo ( a, b, c )&#123; var res = a &gt; b ? a : b; res = res &gt; c ? res : c; return res;&#125;// Functionvar func = new Function( 'a', 'b', 'c', 'var res = a &gt; b ? a : b;res = res &gt; c ? res : c;return res;' )]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数的构造函数Function]]></title>
    <url>%2F2016%2F09%2F10%2Ffunction%2F</url>
    <content type="text"><![CDATA[函数的构造函数Function在 js 中 使用Function可以实例化函数对象。也就是说在 js 中函数与普通对象一样, 也是一个对象类型. 函数是 js 中的一等公民. 函数是对象, 就可以使用对象的动态特性 函数是对象, 就有构造函数创建函数 函数是函数, 可以创建其他对象 函数是唯一可以限定变量作用域的结构 要解决的问题 Function 如何使用 Function 与函数的关系 函数的原型链结构]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型式继承]]></title>
    <url>%2F2016%2F09%2F01%2F%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型式继承 观察：DOM对象的原型链 原型式继承就是利用修改原型链的结构( 增加一个节点, 删除一个节点, 修改节点中的成员 ), 来使得实例对象可以使用整条链中的所有成员. 绘制原型链结构注意：函数也有__proto__属性，暂时不考虑这个！ 观察如下代码，绘制相应的原型链结构图: 12function Person()&#123;&#125;;var p = new Person(); 对应的原型链结构图为： 练习： 绘制{}的原型链结构图 绘制[]的原型链结构图 注意： 在 js 中, 所有的对象字面量在解析以后, 就是一个具体的对象了. 那么可以理解为 调用的 对应的构造方法. 例如在代码中写上 {}, 就相当于new Object() 例如代码中有 [], 就相当于new Array() 例如代码中有 /./, 就相当于new RegExp( &#39;.&#39; ) 注意: 在底层理论执行的过程中, 是否有调用构造函数, 不一定. 和浏览器的版本有关. 练习：绘制如下代码的原型链结构: 12345678910var o = &#123; appendTo: function ( dom ) &#123; &#125;&#125;;function DivTag() &#123;&#125;DivTag.prototype = o;var div = new DivTag();]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型相关的概念]]></title>
    <url>%2F2016%2F08%2F28%2F%E5%8E%9F%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[#原型相关的概念 ##1. 神秘对象称与构造函数 神秘对象就是构造函数的 “原型属性” 简称原型 (构造函数的原型) ##2. 神秘对象与构造函数所创建出来的对象 神秘对象针对构造函数创建出来的对象称为 “原型对象” 简称原型 (对象的原型） ##3. 原型继承 构造函数创建的对象 继承自 构造函数的原型属性 构造函数创建的对象 继承自 该对象的原型对象 原型中的成员, 可以直接被实例对象所使用 实例对象直接 “含有” 原型中的成员 因此实例对象 继承自 原型 这样的继承就是 “原型继承”]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型的使用]]></title>
    <url>%2F2016%2F08%2F25%2F%E5%8E%9F%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原型的使用1. 使用对象的动态特性1234567function Person () &#123; &#125;Person.prototype.func = function () &#123; console.log( 'something' );&#125;;var p = new Person();p.func(); 2. 直接替换原型对象12345678910function Person () &#123; &#125;;Person.prototype = &#123; func: function () &#123; console.log( '22222' ); &#125;&#125;;var p = new Person();p.func(); 3. 直接替换原型会出现的问题123456789101112131415161718function Person () &#123; &#125;Person.prototype.func = function () &#123; console.log( 'something' );&#125;;var p = new Person();Person.prototype.func = function () &#123; console.log( 'something' );&#125;;var p1 = new Person();p.func();p1.func(); 替换原型之后，在替换前创建出来的对象和替换后创建出来的对象的原型对象不一致]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链结构]]></title>
    <url>%2F2016%2F08%2F22%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[原型链结构凡是对象就有原型, 原型又是对象, 因此凡是给定义一个对象, 那么就可以找到他的原型, 原型还有原型. 那么如此下去, 就构成一个对象的序列. 称该结构为原型链. 使用构造函数创建出对象, 并且没有利用赋值的方式修改原型, 就说该对象保留默认的原型链. 默认原型链结构是什么样子呢? 12345function Person() &#123;&#125;var p = new Person();// p 具有默认的原型链 默认的原型链结构就是:当前对象 -&gt; 构造函数.prototype -&gt; Object.prototype -&gt; null 在实现继承的时候, 有时会利用替换原型链结构的方式实现原型继承, 那么原型链结构就会发生改变 1234567function ItcastCollection () &#123;&#125;ItcastCollection.prototype = [];var arr = new ItcastCollection();// arr -&gt; [] -&gt; Array.prototype -&gt; Object.prototype -&gt; null// var arr = new Array();]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用原型解决构造函数问题]]></title>
    <url>%2F2016%2F08%2F18%2F%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%E8%A7%A3%E5%86%B3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 关键点 每一个函数在定义的时候，都会有跟它关联的一个对象被创建出来 每一个由构造函数创建出来的对象，都会默认的和构造函数的神秘对象关联 当使用一个方法进行属性或者方法访问的时候，会先在当前对象内查找该属性和方法 如果当前对象内未找到，就回去跟它关联的神秘对象内进行查找 1234567891011function Person(name, age)&#123; this.name = name; this.age = age; this.sayHi = function()&#123; console.log("Hello!"); &#125;;&#125;var p = new Person("张三", 18);p.sayHi(); //当前对象内有这个方法，所以不会去神秘对象内进行查找var p1 = new Person("李四", 19);p1.sayHello(); //当前对象没没有找到这个方法，所以去神秘对象内进行查找 问题来了，如何访问到这个神秘对象呢？123//可以通过 构造函数.prototype 访问这个神秘对象console.log(Person.prototype); 当尝试给这个对象新增一个方法之后:123Person.prototype.sayHello = function()&#123; console.log("我是神秘对象中的方法");&#125;; 使用p,p1都可以访问这个方法： 12p.sayHello();p1.sayHello(); 总结： 所有对象共享神秘对象(构造函数.prototype)内的属性和方法。 2. 解决方案既然所有对象共享神秘对象(构造函数.prototype)内的属性和方法。我们只需要将需要共享的东西，也就是重复占用内存的东西，全部都放到 神秘对象(构造函数.prototype)中，那么所有对象就都可以使用，并且内存里面也只有一份了。 改造构造函数 1234567891011121314function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.sayHi = function()&#123; console.log("你好");&#125;;//测试var p = new Person("张三", 18);var p1 = new Person("李四", 19);console.log(p.sayHi == p1.sayHi); //输出true 3.常见的错误3.1. 将属性写在神秘对象（构造函数.prototype）内1234567891011function Car(name)&#123; this.name = name;&#125;function Person() &#123;&#125;Person.prototype.name = '张三'; //基本类型的属性影响不大Person.prototype.car = new Car("法拉利"); //引用类型的属性，会被所有的对象共享var p = new Person(); 3.2. 赋值的错误123456789101112131415161718function Person() &#123;&#125;Person.prototype.name = '张三';var p1 = new Person();var p2 = new Person();p1.name = '李四';console.log( p1.name );console.log( p2.name );// 如果是访问数据, 当前对象中如果没有该数据就到构造函数的原型属性中去找// 如果是写数据, 当对象中有该数据的时候, 就是修改值; 如果对象没有该数据, 那么就添加值]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__proto__]]></title>
    <url>%2F2016%2F07%2F11%2Fproto%2F</url>
    <content type="text"><![CDATA[对象的__proto__属性1、标识符命名规则 区分大小写,Name和name是两个不同的变量 标识符可以以下划线_,美元符$或者字母开头，但是不能是数字 标识符可以由下划线_，美元符$，字母，数字组成 2.神秘对象的访问构造函数的prototype属性之前我们访问神秘对象的时候，使用的是原型属性 prototype 12345function Person()&#123;&#125;//通过构造函数的原型属性prototype可以直接访问原型Person.prototype; 在之前是无法通过构造函数创建出来的对象访问原型的 123456function Person()&#123;&#125;var p = new Person();//以前不能直接通过p来访问神秘对象 实例对象的__proto__属性__proto__属性最早是火狐浏览器引入的，用以通过实例对象来访问原型，这个属性在早期是非标准的属性 有了__proto__属性，就可以通过构造函数创建出来的对象直接访问神秘对象 1234567891011121314function Person()&#123;&#125;var p = new Person();//实例对象的__proto__属性可以方便的访问到原型对象p.__proto__;//既然使用构造函数的`prototype`和实例对象的`__proto__`属性//都可以访问原型对象//就有如下结论p.__proto__ === Person.prototype; 3.__proto__属性的用途 可以用来访问原型 在实际开发中除非有特殊的需求，不要轻易的使用实例对象的__proto__属性去修改原型的成员， 在调试过程中，可以轻易的查看原型的成员 tips: 早期如何通过实例对象访问原型？ 可以使用实例对象访问构造函数属性constuctor 12var p = new Person();p.constructor.prototype; 4.给实例继承自原型的属性赋值需要注意的问题 1234567891011function Person()&#123;&#125;;Person.prototype.name = "周华健";var o1 = new Person();var o2 = new Person();o1.name = "李宗盛"; //这里修改的不是原型对象的name属性，而是给o1自己新增了一个name属性，进行了赋值//我们可以对比一下o1和o2的name值console.log(o1.name , o2.name);]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承的实现方式]]></title>
    <url>%2F2016%2F06%2F07%2F%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[继承的实现方式在上一节内容中，最终的结论就是可以通过继承来让dog对象可以使用animal对象的属性和方法，那怎么实现继承呢？ 1. 最简单的继承实现直接遍历父对象的属性，将所有的属性加到当前对象上 1234567891011121314151617var animal = &#123; name:"Animal", sex:"male", age:5, bark:function()&#123; console.log("Animal bark"); &#125;&#125;;var dog = &#123;&#125;;for (var k in animal)&#123; dog[k]= animal[k];&#125; 2. 原型继承每一个构造函数都有prototype原型属性，通过构造函数创建出来的对象都继承自该原型属性。所以可以通过更改构造函数的原型属性来实现继承。 12345678910111213141516171819202122232425262728293031323334353637383940function Dog()&#123; this.type = "yellow Dog";&#125;function extend(obj1, obj2)&#123; for (var k in obj2)&#123; obj1[k] = obj2[k]; &#125;&#125;;//使用混入的方式，将属性和方法添加到构造函数的原型属性上，构造函数所创建出来的实例就都有了这些属性和方法。extend(Dog.prototype, &#123; name:"", age:"", sex:"", bark:function()&#123;&#125;&#125;)//使用面向对象的思想把extend方法重新封装//extend是扩展的意思，谁要扩展就主动调用extend这个方法//所以extend应该是对象的方法，那现在我们要扩展的是构造函数的原型对象//所以给构造函数的原型对象添加一个extend方法//如下：Dog.prototype.extend = function(obj)&#123; for (var k in obj)&#123; this[k]=obj[k]; &#125;&#125;//调用方式就变成了下面这种形式Dog.prototype.extend(&#123; name:"", age:"", sex:"", bark:function()&#123;&#125;&#125;);]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2016%2F06%2F07%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承的概念在JavaScript中，继承就是当前对象可以使用其他对象的方法和属性。 12345678910111213141516var animal = &#123; name:"Animal", sex:"male", age:5, bark:function()&#123; console.log("Animal bark"); &#125;&#125;;var dog = &#123;&#125;;//当前有两个对象，一个animal,一个dog//dog没有属性和方法//但是我们知道，dog属于animal，所以animal的方法和属性，都可以被dog使用//如何让dog可以使用animal的属性和方法呢？//通过继承就可以实现]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2016%2F06%2F06%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[什么是递归在程序中，所谓的递归，就是函数自己直接或间接的调用自己。调用自己分两种： 直接调用自己 间接调用自己 就递归而言最重要的就是跳出结构，因为跳出了才可以有结果. 化归思想化归思想：将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。 递归思想就是将一个问题转换为一个已解决的问题来实现 假如有一个函数f, 如果它是递归函数的话, 那么也就是说函数体内的问题还是转换为 f的形式. 123function f() &#123; ... f( ... ) ...&#125; 例子: 1, 2, 3, 4, 5, …, 100 求和 首先假定递归函数已经写好, 假设是foo. 即foo(100)就是求1到100的和 寻找递推关系. 就是n与n-1, 或n-2之间的关系:foo( n ) == n + foo( n - 1 ) 12var res = foo(100);var res = foo(99) + 100; 将递推结构转换为递归体 123function foo(n)&#123; return n + foo( n - 1 );&#125; 上面就是利用了化归思想： 将 求 100 转换为 求 99 将 求 99 转换为 求 98 … 将求 2 转换为 求 1 求 1 结果就是 1 即: foo( 1 ) 是 1 将临界条件加到递归体中(求1的结果为1) 1234function foo( n ) &#123; if ( n == 1 ) return 1; return n + foo( n - 1 );&#125; 练习: 求 1, 3, 5, 7, 9, … 第n项的结果与前n项和. 序号从0开始 先看求第n项 首先假定递归函数已经写好, 假设是fn. 那么第n项就是fn(n) 找递推关系:fn(n) == f(n-1) + 2 递归体 123function fn(n) &#123; return fn(n-1) + 2;&#125; 找临界条件 求 n -&gt; n-1 求 n-1 -&gt; n-2 … 求 1 -&gt; 0 求 第 0 项, 就是 1 加入临界条件 1234function fn( n ) &#123; if ( n == 0 ) return 1; return fn( n-1 ) + 2;&#125; 再看求前n项和 假设已完成, sum( n ) 就是前 n 项和 找递推关系: 前 n 项和 等于 第 n 项 + 前 n-1 项的和 递归体 123function sum( n ) &#123; return fn( n ) + sum( n - 1 );&#125; 找临界条件 n == 1结果为 1 加入临界条件 1234function sum( n ) &#123; if (n == 0) return 1; return fn(n) + sum(n - 1);&#125; 练习 2, 4, 6, 8, 10 第 n 项与 前 n 项和 解题方法和上一题一样。 练习 现有数列: 1, 1, 2, 4, 7, 11, 16, … 求 第 n 项, 求前 n 项和. 求第n项 假设已经得到结果 fn, fn( 10 ) 就是第 10 项 找递推关系 0, 1 =&gt; fn( 0 ) + 0 = fn( 1 ) 1, 2 =&gt; fn( 1 ) + 1 = fn( 2 ) 2, 3 =&gt; fn( 2 ) + 2 = fn( 3 ) … n-1, n =&gt; fn( n-1 ) + n - 1 = fn( n ) 递归体也就清楚了 临界条件是 n == 0 =&gt; 1 1234function fn( n ) &#123; if ( n == 0 ) return 1; return fn( n-1 ) + n - 1;&#125; 前n项和1234function sum( n ) &#123; if ( n == 0 ) return 1; return sum( n - 1 ) + fn( n );&#125; 练习 Fibonacci 数列: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … 求其第 n 项. 递推关系:fn(n) == fn(n-1) + fn(n - 2) 1234function fib( n ) &#123; if ( n == 0 || n == 1 ) return 1; return fib( n - 1 ) + fib( n - 2 );&#125; 练习 阶乘：一个数字的阶乘表示的是从 1 开始 累乘到这个数字. 例如 3! 表示 1 2 3. 5! 就是 1 2 3 4 5. 规定 0 没有阶乘, 阶乘从1开始。 求n的阶乘 1234function foo ( n ) &#123; if ( n == 1 ) return 1; return foo( n - 1 ) * n;&#125; 练习 求幂 求幂就是求 某一个数 几次方 2*2 2 的 平方, 2 的 2 次方 求 n 的 m 次方 最终要得到一个函数 power( n, m ) n 的 m 次方就是 m 个 n 相乘 即 n 乘以 (m-1) 个 n 相乘 1234function power ( n, m ) &#123; if ( m == 1 ) return n; return power( n, m - 1 ) * n;&#125;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2016%2F06%2F06%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包的概念闭包从字面意思理解就是闭合, 包起来. 简单的来说闭包就是,一个具有封闭的对外不公开的, 包裹结构, 或空间. 在JavaScript中函数可以构成闭包. 一般函数是一个代码结构的封闭结构, 即包裹的特性, 同时根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. 因此说函数可以构成闭包. 闭包要解决什么问题？ 闭包内的数据不允许外界访问 要解决的问题就是间接访问该数据 函数就可以构成闭包, 要解决的问题就是访问到函数内部的数据 我们观察下面的函数foo，在foo内部有一个变量num，能否在函数外部访问到这个变量num呢？ 1234567function foo () &#123; var num = 123; return num;&#125;var res = foo();console.log( res ); // =&gt; 123 分析： 在上面的代码中，确实可以访问到num这个函数内部的变量。但是能不能多次访问呢？ 不能，因为每次访问都得重新调用一次foo函数，每次调用都会重新创建一个num = 123，然后返回。 解决思路函数内的数据不能直接在函数外被访问，是因为作用域的关系，上级作用域不能直接访问下级作用域中的数据。 但是如果反过来，下级作用域可以直接访问上级作用域中的数据。那么如果在函数foo内定义一个函数，那么在这个内部函数中是可以直接访问foo中的num的。 12345678910111213function foo() &#123; var num = Math.random(); function func() &#123; return num; &#125; return func;&#125;var f = foo();// f可以直接访问num，而且多次访问，访问的也是同一个，并不会返回新的numvar res1 = f();var res2 = f(); 如何获得超过一个数据函数的返回值只能有一个，那按照上面的方法，我们只能对函数内部的一个数据进行操作。怎么操作函数内的多个数据呢？ 可以使用对象，代码如下：12345678910111213function foo () &#123; var num1 = Math.random(); var num2 = Math.random(); //可以将多个函数包含在一个对象内进行返回，这样就能在函数外部操作当前函数内的多个变量 return &#123; num1: function () &#123; return num1; &#125;, num2: function () &#123; return num2; &#125; &#125;&#125; 如何完成读取一个数据和修改这个数据前面讲的都是如何去获取函数内部的数据，接下来我们考虑如何修改函数内部的数据。 同样，也是使用内部的函数进行操作。 1234567891011121314function foo() &#123; var num = Math.random(); //分别定义get和set函数，使用对象进行返回 return &#123; //get_num负责获取数据 get_num: function() &#123; return num; &#125;, //set_num负责设置数据 set_num: function(value) &#123; num = value; &#125; &#125;&#125; 闭包的基本结构一般闭包要解决的的问题就是要想办法间接的获得函数内数据的使用权. 那么我们的可以总结出一个基本的使用模型. 写一个函数, 函数内定义一个新函数, 返回新函数, 用新函数获得函数内的数据 写一个函数, 函数内定义一个对象, 对象中绑定多个函数( 方法 ), 返回对象, 利用对象的方法访问函数内的数据]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number对象]]></title>
    <url>%2F2016%2F05%2F15%2Fnumber%2F</url>
    <content type="text"><![CDATA[Number 对象属性 属性 描述 MAX_VALUE 可表示的最大的数。 MIN_VALUE 可表示的最小的数。 NaN 非数字值。相当于NaN NEGATIVE_INFINITY 负无穷大，溢出时返回该值。相当于-Infinity POSITIVE_INFINITY 正无穷大，溢出时返回该值。相当于Infinity Number 对象方法 方法 描述 toString 把数字转换为字符串，使用指定的基数。 toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字。 toExponential 把对象的值转换为指数计数法。 toPrecision 把数字格式化为指定的长度。 valueOf 返回一个 Number 对象的基本数字值。]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boolean对象]]></title>
    <url>%2F2016%2F04%2F30%2Fboolean%2F</url>
    <content type="text"><![CDATA[Boolean 对象方法 方法 描述 toString() 把逻辑值转换为字符串，并返回结果。 valueOf() 返回 Boolean 对象的原始值。]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Date对象]]></title>
    <url>%2F2016%2F03%2F22%2Fdate%2F</url>
    <content type="text"><![CDATA[Data 对象方法 方法 描述 Date() 返回当日的日期和时间 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth () 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinute s() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒 (0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 parse() 返回1970年1月1日午夜到 指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象 中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 ( 0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象ä­的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换 为字符串。]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的特性]]></title>
    <url>%2F2016%2F02%2F19%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[面向对象的特性JavaScript面向对象的特性 封装性对象是将数据与功能组合到一起, 即封装 js 对象就是 键值对的集合 键值如果是数据( 基本数据, 复合数据, 空数据 ), 就称为属性 如果键值是函数, 那么就称为方法 对象就是将属性与方法封装起来 方法是将过程封装起来 继承性 所谓继承就是自己没有, 别人有,拿过来为自己所用, 并成为自己的东西 传统继承基于模板 js 继承基于对象js继承实现举例：混入（mix） 12345function mix ( o1, o2 ) &#123; for ( var k in o2 ) &#123; o1[ k ] = o2[ k ]; &#125;&#125;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array对象]]></title>
    <url>%2F2016%2F02%2F12%2Farray%2F</url>
    <content type="text"><![CDATA[Array对象属性 属性 描述 length 设置或返回数组中元素的数目。 Array对象方法 方法 描述 concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 shift() 删除并返回数组的第一个元素 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math对象]]></title>
    <url>%2F2016%2F01%2F04%2Fmath%2F</url>
    <content type="text"><![CDATA[Math对象的属性 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 PI 返回圆周率（约等于3.14159）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 Math对象的方法 属性 描述 abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值。 asin(x) 返回数的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 e 的指数。 floor(x) 对数进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y) 返回 x 和 y 中的最高值。 min(x,y) 返回 x 和 y 中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 toSource() 返回该对象的源代码。 valueOf() 返回 Math 对象的原始值。]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String对象]]></title>
    <url>%2F2015%2F12%2F25%2Fstring%2F</url>
    <content type="text"><![CDATA[String 对象属性 属性 描述 length 字符串的长度 String对象方法 方法 描述 anchor() 创建 HTML 锚。 big() 用大号字体显示字符串。 blink() 显示闪动字符串。 bold() 使用粗体显示字符串。 fontcolor() 使用指定的颜色来显示字符串。 fontsize() 使用指定的尺寸来显示字符串。 italics() 使用斜体显示字符串。 link() 将字符串显示为链接。 small() 使用小字号来显示字符串。 strike() 使用删除线来显示字符串。 sub() 把字符串显示为下标。 fixed() 以打字机文本显示字符串。 sup() 把字符串显示为上标。 charAt() 返回在指定位置的字符。 charCodeAt() 返回在指定的位置的字符的 Unicode 编码。 concat() 连接字符串。 fromCharCode() 从字符编码创建一个字符串。 indexOf() 检索字符串。 lastIndexOf() 从后向前搜索字符串。 match() 找到一个或多个正则表达式的匹配。 replace() 替换与正则表达式匹配的子串。 search() 检索与正则表达式相匹配的值。 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。 split() 把字符串分割为字符串数组。 substr() 从起始索引号提取字符串中指定数目的字符。 substring() 提取字符串中两个指定的索引号之间的字符。 toLocaleLowerCase() 把字符串转换为小写。 toLocaleUpperCase() 把字符串转换为大写。 toLowerCase() 把字符串转换为小写。 toUpperCase() 把字符串转换为大写。 toSource() 代表对象的源代码。 toString() 返回字符串。 valueOf() 返回某个字符串对象的原始值。]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markDown语法再次整理]]></title>
    <url>%2F2015%2F11%2F11%2Fmarkdown%E5%86%8D%E6%AC%A1%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、标题第一种：1#h1 h11## h2 h21### h3 h31#### h4 h41##### h5 h51###### h6 h6 第二种：12h1===== h112h2----- h2二、字体形式 斜体 斜体 粗体 斜体加粗 三、块注释（引言部分）使用&gt; 可以嵌套 111 222 333 222 333 444 111 四、列表使用就是html 中的ul 和ol 1使用 * ， + ， - 表示无序列表 列表一 列表二 列表三 1使用: 数字加点 表示有序列表 列表一 列表二 1块与列表混合使用 列表一 内容一 列表二 内容一 五、表格1234567891011使用: 1.第一行为表头2.第二行为分隔线3.后面为表身示例:| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 六、分割线 12345***----_______ 七、加入代码段语法一:1一个tab间距符,或4个空格 function abc(){ console.log(&apos;abc&apos;); } 语法二: 16个`反引号 123function def()&#123; console.log(&apos;def&apos;);&#125; 语法三:1两个`反引号,行内代码 我是alert(1)行内代码; 八、超链接1、网页链接语法一：1使用: [链接文字](链接地址) baidu 语法二：12定义: [标识]:链接地址使用: [百度][标识] 欢迎来到百度 欢迎来到谷歌 语法三:1使用: &lt;连接地址&gt; http://www.baidu.com/ 2、图片语法一:12使用: ![图片Alt](图片地址)![图片](./imgs/server.png) 语法二:1234567定义: [标识]:图片地址使用: ![图片Alt][标记][img_1]:(/imgs/server.png)![百度logo][img_1]]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>markDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http&ajax]]></title>
    <url>%2F2015%2F10%2F07%2Fhttp%E6%9C%8D%E5%8A%A1%26ajax%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、服务器 前言：通俗的讲，能够提供某种服务的机器（计算机）称为服务器 1.1、如何理解服务器？生活中案例： 便利店 《====》 服务器 货架，冰柜，POS机《====》服务器软件 卖零食水果，代收快递 ，充值缴费《====》 服务 相对应的关系： 便利店 ===》 配上货架，冰柜 ===》 卖零食，水果 服务器 ===》 安装服务器软件 ===》 提供服务 编程世界中案例： 服务器《====》 计算机 服务器软件《====》 可存储网页软件，某收发网页软件 服务《====》 存放网页，发送网页 如何增加新的业务？ 问：如果便利店要新增拍照的业务？ 答：增加照相机、背景布。 问：服务器增加发送邮件功能？ 答：安装邮件服务器软件。 1.2、服务器软件使计算机具备提供某种服务能力的应用软件，称为服务器软件，通过安装相应的服务软件，然后进行配置后就可以使计算具备了提供某种服务的能力。 常见的服务器软件有： 文件服务器：Server-U、FileZilla、VsFTP等（FTP是File Transfer Protocol文件传输协议）； 数据库服务器：oracle、mysql、SQL server、DB2、ACCESS等； 邮件服务器：Postfix、Sendmail等； HTTP服务器：Apache、Nginx、IIS、Tomcat、NodeJS等； 服务器想要对外提供什么服务，就安装相应的服务器软件。反之，安装了相应的服务软件，就可以对外提供相应的服务。 1.3、服务器类型按照不同的划分标准，服务器可划分为以下类型： 按软件功能类型可分为： 文件服务器、数据库服务器、邮件服务器、Web服务器等； 按安装操作系统可分为： Linux服务器、Windows服务器等； 按应用软件名称可分为： Apache服务器、Nginx 服务器、IIS服务器、Tomcat服务器、mysql服务器、oracle服务器、 Node服务器等； 本质：无论是按软件功能，还是按软件安装的系统，按软件名称，服务器的本质就是一台装了某款服务器软件，提供某种服务的计算机。 服务器类型类比举例： 水果便利店，生鲜便利店（经营类别） 711便利店，喜事多（名称） 日本便利店，中国便利店（地域） 本质：都是提供售货，和一些便民服务。 1.4、HTTP服务器即网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。 HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为服务端开发。 常见的运行在服务端的编程语言包括 php、java、.net、Python、Ruby、Perl等。 服务器总结： 服务器就是计算机，通过安装服务器软件，才能向外提供服务。 根据服务器软件的功能，名称，安装的系统这些不同的标准，我们可以划分出不同类型的服务器。 HTTP服务器主要提供网站浏览服务，通常可以结合某编程语言进行开发，这种通常称为服务器开发。 2、客户端2.1.如何理解客户端？ 客户端：电脑，手机，iPad平板安装了客户端软件，可以称之为客户端。 客户端：安装客户端软件，索取服务一方（向服务器获取） 服务端：安装服务端软件，提供服务一方（向客户端提供） 2.2 索取服务与提供服务理解？QQ聊天案例： （我的）手机QQ===》编辑消息===》发送===》信息去哪里了？ （朋友）手机QQ===》接收消息 问：为什么可以发消息，可以接收？ 问：消息发出去都会去哪里？ 具有向服务器索取服务能力的终端，如比如 手机、电脑等，通过安装不同的客户端软件，可以获取不同的服务，比如通过QQ获得即时通讯服务、通过迅雷获得下载服务等。 2.3 常见的客户端软件： 铁路12306 ===》 订购车票服务 今日头条，百度新闻 ===》 看新闻服务（关心国家大事）。 迅雷 ===》 下载小片子 Foxmail ===》收发邮件 2.4.客户端如何分类？ 系统划分：IOS端，安卓端，window 设备划分：手机端，电脑端 特性划分：浏览器（网页应用），非浏览器（桌面应用） 以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为前端开发。 2.5 CS/BS软件（了解） CS 就是（client/server） 客户端+服务器 的应用。 案例：手机QQ，LOL游戏 , 手机微信 特点： 需要安装，手机、电脑桌面应用 性能更高效，更稳定，使用更流畅 开发及维护难度增大 兼容各种系统平台 BS 就是（browser/server） 浏览器+服务器 的应用 案例：网页QQ，新浪网站，网页地图 特点： 不用安装，运行在浏览器网页应用 性能相对较低，流畅性弱（依赖浏览器） 开发维护相对更快 兼容浏览器 小结：CS手机电脑桌面用应，BS浏览器网页应用。 客户端总结： 客户端就是手机，iPad平板，电脑，等智能设备，装有了客户端软件，可以获取服务器上的服务。 服务器是提供服务一方，客户端是索取服务一方（向服务器索取） 客户端通常按设备，系统划分，把浏览器中网页应用单独划分，则有了，我们常说的（BS/CS）应用。 工作中我们做的都是BS（网页应用），又称前端开发，需要后台配合。 3、网络基础3.1 如何理解这些概念？生活中案例： 我要找天安门好日子便得店，取快递？我不知道详细地址，怎么办？ 店铺详细地址：北京市昌平区天安门路100号A003铺位（ip唯一） 店铺名称：天安门好日子便利店（域名） 店铺业务：卖零食，收快递（端口） 把店铺名称和详细地址对应：问自己的家人 ===》 再问外面的人 （DNS寻址） 最后再拿快递（获取服务） 3.2 IP地址IP地址 : 每个连接在互联网上的主机电脑在网络上的唯一标识（身份证，手机电话号码） 形式：一个32位地址(192.168.10.100) 查看本机IP地址：ipconfig、ifconfig（linux） 查看某某网站IP地址：ping www.baidu.com 3.3、域名由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“面具” 查看域名对应的IP地址 ping 3.4、DNS服务DNS（Domain Name System）因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网。 简单的说就是指记录IP地址和域名之间对应关系的服务器电脑。 查找优先级： 本机hosts文件、DNS服务器( 专干对应域名IP的活 ) 刷新DNS： ipconfig /flushdns 3.5、端口端口号是计算机与外界通讯交流的出口，每个端口对应不同的服务。 查看端口占用情况： netstat -an 常见端口号 80、8080、3306、21、22 4、搭建HTTP服务器 Windows + Apache + Mysql + PHP。 4.1 什么是集成开发环境软件？360一键安装包 : 360浏览器 + 360杀毒 + 360软件管家 + 360手机助手 phpStudy集成软件: { windows } + Apache + Mysql + PHP，首字母组合。 4.2 安装phpStudy安装phpStudy，解压双击安装(非中文路径)，其它默认安装。 4.3 管理HTTP服务任务图标绿色为正常启动状态通过图形控制台可以启动、重启、停止所有服务 注意事项：1、检查网络是不是通的 ping 对方IP2、检查防火墙是否开启，如果开启将不能正常被访问3、理解默认索引4、确保端口没有被其它程序占用5、修改配置要格外小心，禁止无意修改其它内容 4.4 访问根目录 1、服务器软件安装后，输入ip地址（或者回环IP地址：127.0.0.1）。 2、默认会打开 WWW 目录，该目录为根目录 3、如果文件夹中，有index.html 或 index.php文件，会被默认打开。 4.5 更改网站内容将我们制作好的网页拷贝到配置好的根目录下，浏览器访问127.0.0.1即可。 4.6 配置多个网站步骤1：phpstudy其他选项设置 步骤2：phpstudy其他选项设置 —-&gt; 站点和域名管理 步骤3：phpstudy 其他选项设置 —-&gt;打开host文件 注意：如果修改host文件，出现权限问题。则将文拷贝到桌面，修改。然后再粘到C:\Windows\System32\drivers\etc 文件夹下 把域名和ip地址对应（以后浏览器，看到这个网址代表的就会找这个IP的电脑） 完成配置后，则可以域名，或者ip形式访问。 4.7 开放目录形式访问权限 注意：当网站设置了域名后（为了安全性），phpstudy默认会关闭目录形式的访问(没有Index文件，不显示目录) 为了开发调式方便，我们可以自己打开目录形式的访问。 步骤1： phpstudy其他选项设置—&gt;phpstudy设置—-&gt;允许目录列表（勾选） 步骤2： phpstudy其他选项设置—&gt;打开配置文件—&gt; vhosts-conf 步骤3：更改options 配置 修改如下： 如配有多个网站则逐一修改即可。 修改完成，重启phpstudy软件，则可以显示网站的目录 4.8 更改默认打开首页更改步骤1：phpstudy其他选项设置 更改步骤2：phpstudy设置 —-&gt; 端口常规设置 默认进入网站时，会寻找目录中的index.html ，index.php , index.htm文件 可以把index.php文件，排在最前面，这样可以优先找到index.php文件，因为我们下午就要学习php开发。 5、PHP基础学习目标： 基础的语法,变量,数据类型，数组使用，分支循环语句。 用超全局变量（$_GET, $_POST, $_FILES）接收表单的数据。 掌握常用的函数，和几种输出数据方式 掌握字符串拼接，以及php后台渲染网页。 书写注意事项： 文件以.php后缀结尾，所有程序包含在php标签中 &lt;?php 这里是代码 ?&gt; 避免使用中文目录和中文文件名 php页面无法直接打开，需要运行在服务器环境当中 5.1、最简单的php程序&lt;?php // 用来指定编码集 header(&apos;Content-Type:text/html; charset=utf-8&apos;); /*这是一个最简单的php程序*/ echo &apos;hello world!&apos;; ?&gt; 5.3、变量1、变量以$开头 字母/数字/下划线 不能以数字开头2、大小写敏感（区分大小写） // 声明一个变量$a并赋值为10 $a = 10; // 输出一个变量$a echo $a; // 声明一个变量$b并赋值为10 $b = 10; // 输出一个变量$b echo $b; // 输出顺序是自上向下的 // 相当于 js dcoument.write() 5.3、数据类型字符型 $str = &apos;hello world!&apos;; 整型 $num = 10; 浮点型 $float = 10.5; 布尔型 $bool = true; 数组 // Javascript 数组定义方式 var arr = [1, 2, 3] // arr[0]、arr[1]、arr[1] // PHP 是这样定义数组的 // 这种方式叫做**索引数组** $arr = array(1, 2, 3); // echo $arr[0]; // echo $arr[2]; // 定义方式和Javascript有区别，但是访问方式是一样的 // var obj = {name: itcast, age: 10} // PHP另一种定定数组的方式，所表达的意义和Javascript一样， // 只是语法格式不一样 // 这种方式叫做**关联数组** $arr1 = array(&apos;name&apos;=&gt;&apos;itcast&apos;, &apos;age&apos;=&gt;10); // echo $arr1[&apos;name&apos;]; // echo $arr1[&apos;age&apos;]; 对象 // Javascript var obj = {name: itcast, age: 10} // PHP需要先创建一个类，下面就是创建过程 class Person { public $name = &apos;itcast&apos;; public $age = 10; } $person = new Person; // PHP访问一个对象属性的语法是不一样的 echo $person-&gt;name; // obj[&apos;name&apos;]; obj.name 不行 NULL //PHP中一种特殊的数据类型，表示空值，即表示没有为该变量设置任何值null(空值)不区分大小写，null和NULL是一样的。 单引号&amp;双引号区别： 单引号内部的变量不会执行双引号会执行 $name = &apos;小明&apos;; echo &apos;name is $name&apos;;//输出 name is $name echo &apos;&lt;br&gt;&apos;; echo &quot;name is $name&quot;;//输出 name is 小明 索引数组、关联数组（了解即可） 5.4、运算符 &amp; 3种内容输出基本与Javascript语法一致 . 号表示字符串拼接符，Javascript中为+号 echo：输出简单数据类型，如字符串、数值 /** * 连接符 * Javascript中用+号表示连接符 * PHP中使用.点号 */ $hello = &apos;hello&apos;; $world = &apos;world!&apos;; // PHP连接符用.号 echo $hello . &apos; &apos; .$world; print_r()：输出复杂数据类型，如数组 $arr = array(&apos;itcast&apos;, &apos;今年&apos;, &apos;10岁了&apos;); // 只能输出简单类型 echo $arr; // 可以打印数组，但是输出的是一个数组的结构 print_r($arr); var_dump()：输出详细信息，如对象、数组（了解） $arr = array(&apos;itcast&apos;, &apos;今年&apos;, &apos;10岁了&apos;); // 只能输出简单类型 echo $arr; // 输出详细信息 var_dump($arr); $hello = &apos;hello&apos;; // 输出详细信息 var_dump($hello); 5.5、函数基本与Javascript基本一致 函数名对大小写不敏感默认参数（了解即可） // 1、PHP中函数不可以省略参数 // 2、PHP可以设置默认参数 function sayHello($name=&apos;web developer&apos;) { echo $name . &apos;你好!&apos;; } sayHello(); 5.6、分支，循环语句/** * 分支控制语句、循环语句 * 与Javascript一样 * foreach 数组遍历函数，类似Javascript中的 for in */ $name = &apos;itcast1&apos;; if($name == &apos;itcast&apos;) { echo &apos;我已经在&apos; . $name . &apos;学习&apos;; } else { echo &apos;我还没有学习过编程&apos;; } /** * 分支控制语句、循环语句 * 与Javascript一样 * foreach 数组遍历函数，类似Javascript中的 for in */ // 索引数组 $arr = array(&apos;itcast&apos;, &apos;今年&apos;, &apos;10岁了&apos;); // PHP函数，计算数组的长度 $length = count($arr); // echo $length; // 和Javascript是一样的 // for($i=0; $i&lt;$length; $i++) { // echo $arr[$i]; // } foreach($arr as $k=&gt;$v) { echo $k . &apos;~~~&apos; . $v; }; // 关联数组 $arr1 = array(&apos;name&apos;=&gt;&apos;itcast&apos;, &apos;age&apos;=&gt;&apos;10&apos;); // 验证关联数组不可以按索引下标来访问 // echo $arr1[0]; //PHP遍历一个关联数组 foreach($arr1 as $key=&gt;$val) { echo $key . &apos;~~~&apos; . $val; } // 实际开发都是用foreach来遍历数组的 5.7、表单处理表单name属性的是用来提供给服务端接收所传递数据而设置的 表单action属性设置接收数据的处理程序 表单method属性设置发送数据的方式 当上传文件是需要设置 enctype=”multipart/form-data”，且只能post方式 $_GET接收 get 传值 $_POST接收 post 传值 $_FILES接收文件上传 html代码： &lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;label&gt;用户：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;/div&gt; &lt;/form&gt; &lt;form action=&quot;login.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;label&gt;图片：&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;image&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/div&gt; &lt;/form&gt; 保存上传文件 上传的临时文件,一会就会被自动删除,我们需要将其移动到保存的位置 move_uploaded_file($_FILES[&apos;image&apos;][&apos;tmp_name&apos;], &apos;test.jpg&apos;); move_uploaded_file参数: 参数1:移动的文件 参数2:目标路径 5.8、文件导入&amp;&amp;常用php函数文件导入 include &apos;07.form.html&apos;; require &apos;07.form.php&apos; 常用函数 $array = array( &apos;username&apos;=&gt;&apos;itcast&apos;, &apos;password&apos;=&gt;&apos;123456&apos; ); echo &apos;获取数组的长度：&apos;.count($array); echo &apos;&lt;br&gt;&apos;; echo &apos;判断是否在数组中：&apos;.in_array(&apos;itcast&apos;,$array); echo &apos;&lt;br&gt;&apos;; echo &apos;检测数组中是否存在key：&apos;.array_key_exists(&apos;username&apos;,$array); 5.9、应用实例1、用户登录 html页面： &lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;label&gt;用户：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;/div&gt; &lt;/form&gt; php页面： &lt;?php header(&apos;Content-Type:text/html; charset=utf-8&apos;); /*数据库当中的数据*/ $userInfo = array( &apos;username&apos;=&gt;&apos;itcast&apos;, &apos;password&apos;=&gt;&apos;123456&apos; ); /*拿到提交过来的数据*/ $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; /*去匹配数据库当中的数据*/ if($userInfo[&apos;username&apos;] == $username &amp;&amp; $userInfo[&apos;password&apos;] == $password){ header(&apos;refresh:0;url=jdMsite/&apos;); }else{ header(&apos;refresh:0;url=login.html&apos;); } ?&gt; 2、动态网站 京东首页 index.php页面 &lt;?php header(&apos;Content-Type:text/html; charset=utf-8&apos;); $product_list = array( array( &apos;imgUrl&apos;=&gt;&apos;images/detail01.jpg&apos;, &apos;newPrice&apos;=&gt;&apos;15.00&apos;, &apos;oldPrice&apos;=&gt;&apos;19.00&apos; ), array( &apos;imgUrl&apos;=&gt;&apos;images/detail02.jpg&apos;, &apos;newPrice&apos;=&gt;&apos;133.00&apos;, &apos;oldPrice&apos;=&gt;&apos;234.00&apos; ), array( &apos;imgUrl&apos;=&gt;&apos;images/detail01.jpg&apos;, &apos;newPrice&apos;=&gt;&apos;340.00&apos;, &apos;oldPrice&apos;=&gt;&apos;1432.00&apos; ) ); include &apos;index.html&apos;; ?&gt; index.html页面 &lt;!--掌上秒杀的内容是会更新的而且是后台更新--&gt; &lt;ul class=&quot;sk_product&quot;&gt; &lt;?php foreach($product_list as $key =&gt; $val){ ?&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;&lt;?php echo $val[&apos;imgUrl&apos;] ?&gt;&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; &lt;p class=&quot;new_price&quot;&gt;&amp;yen;&lt;?php echo $val[&apos;newPrice&apos;] ?&gt;&lt;/p&gt; &lt;p class=&quot;old_price&quot;&gt;&amp;yen;&lt;?php echo $val[&apos;oldPrice&apos;] ?&gt;&lt;/p&gt; &lt;/li&gt; &lt;?php } ?&gt; &lt;/ul&gt; 京东分类 category.php页面： &lt;?php header(&apos;Content-Type:text/html; charset=utf-8&apos;); $category = array( &apos;热门推荐&apos;, &apos;潮流女装&apos;, &apos;品牌男装&apos;, &apos;内衣配饰&apos;, &apos;家用电器&apos;, &apos;电脑办公&apos;, &apos;手机数码&apos;, &apos;母婴频道&apos;, &apos;图书&apos;, &apos;家居家纺&apos;, &apos;居家生活&apos;, &apos;家具建材&apos;, &apos;热门推荐&apos;, &apos;潮流女装&apos;, &apos;品牌男装&apos;, &apos;内衣配饰&apos;, &apos;家用电器&apos;, &apos;电脑办公&apos;, &apos;手机数码&apos;, &apos;母婴频道&apos;, &apos;居家生活&apos;, &apos;手机数码&apos;, &apos;母婴频道&apos;, &apos;图书&apos;, &apos;家居家纺&apos;, &apos;居家生活&apos;, &apos;潮流女装&apos;, &apos;家具建材&apos;, &apos;热门推荐&apos;, &apos;潮流女装&apos;, ); //echo count($category); include &apos;category.html&apos;; ?&gt; category.html页面： &lt;!--左侧分类--&gt; &lt;div class=&quot;jd_cate_left&quot;&gt; &lt;ul&gt; &lt;?php foreach($category as $key=&gt;$val){ ?&gt; &lt;li class=&quot;&lt;?php echo $key==1?&apos;now&apos;:&apos;&apos; ?&gt;&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;?php echo $val ?&gt;&lt;/a&gt;&lt;/li&gt; &lt;?php } ?&gt; &lt;/ul&gt; &lt;/div&gt; 后面课程中会用到的php函数（不用记） count 计算数组长度 in_array 值是否在数组中 array_push 往数据中追加一个元素 array_rand 随机取出数据中一个元素的索引值 array_key_exists 检测数组中是否存在key move_uploaded_file 将上传的文件移到新的位置 file_get_contents 读取文件 file_put_contents 写入文件 json_decode 对 JSON 格式的字符串进行解码 json_encode 对变量进行 JSON 编码 6、网络传输协议6.1、如何理解协议？ 我要租房====》租房协议====》我和房东的约定 我要贷款====》货款协议====》我和贷款公司约定 协议：双方要共同遵守的一些约定。目的：租到房子，贷到款 6.1、常见网络传输协议1、HTTP、HTTPS 超文本传输协议 2、FTP 文件传输协议 3、SMTP 简单邮件传输协议 协议：客户端与服务器端的约定。目的：传输信息，怎么传 6.2、http协议 http协议：浏览器和服务器的约定。目的：相互通信，传输文件 超文本传输协议（HTTP，HyperText Transfer Protocol) 网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。 HTML Hypertext Markup Language HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。 即HTTP协议主要由请求和响应构成。 常用请求方法 POST、GET、PUT、DELETE 我们通过浏览器插件 FireFox httpFox 调试。ctrl shift f2 调用 6.2.1、请求和请求报文请求由客户端发起，其规范格式为：请求行、请求头、请求主体。 1、请求行 由请求方式、请求URL和协议版本构成 GET /day01/code/login.php?username=123&amp;password=123 HTTP/1.1 POST /day01/code/login.php HTTP/1.1 2、请求头 Host：localhost请求的主机 Cache-Control：max-age=0控制缓存 Accept：/ 接受的文档MIME类型 User-Agent：很重要 Referer：从哪个URL跳转过来的 Accept-Encoding：可接受的压缩格式 If-None-Match：记录服务器响应的ETag值，用于控制缓存 (此值是由服务器自动生成的) If-Modified-Since：记录服务器响应的Last-Modified值 (此值是由服务器自动生成的) 3、请求主体 即传递给服务端的数据 注：当以post形式提交表单的时候，请求头里会设置 Content-Type: application/x-www-form-urlencoded，以get形式当不需要 GET方式: POST方式: 6.2.2、 响应和响应报文响应由服务器发出，其规范格式为：状态行、响应头、响应主体。 1、状态行 由协议版本号、状态码和状态信息构成 HTTP/1.1 200 OK 2、响应头 Date：响应时间 Server：服务器信息 Last-Modified：资源最后修改时间 由服务器自动生成 ETag：资源修改后生成的唯一标识 由服务器自动生成 Content-Length：响应主体长度 Content-Type：响应资源的类型 3、响应主体 即服务端返回给客户端的内容； 状态码 常见的有200代表成功、304文档未修改、403没有权限、404未找到、500服务器错误 状态码值参考： 6.3 谷歌浏览器中查看请求报文与响应报文步骤：f12开发者工具===》Network===》All 7、AJAX编程 即 Asynchronous [e’sɪŋkrənəs] Javascript And XML，AJAX 不是一门的新的语言，而是对现有技术的综合利用。本质是在HTTP协议的基础上以异步的方式与服务器进行通信。 7.1、 异步同步和异步概念： 同步: 指的就是事情要一件一件做。等做完前一件才能做后一件任务 异步: 不受当前任务的影响，两件事情同时进行，做一件事情时，不影响另一件事情的进行。 编程中：异步程序代码执行时不会阻塞其它程序代码执行,从而提升整体执行效率。 网页异步应用： 验证你的用户名是否已经存在（一边输入，一边获取你的信息，和后台比对）。 百度搜索提示，及相关内容展示（一边输入，一边找出了你可能要的内容）。 新浪微博自动加载（一边滚动，一边加了新的一页数据给你）。 XMLHttpRequest可以以异步方式的处理程序。 7.2、 XMLHttpRequest浏览器内建对象，用于在后台与服务器通信(交换数据) ，由此我们便可实现对网页的部分更新，而不是刷新整个页面。 /*js 内置的 http 请求对象 XMLHttpRequest*/ /*1.怎么使用 这个内置对象*/ var xhr = new XMLHttpRequest; /*2.怎么样去组请求*/ /*请求的行*/ xhr.open(&apos;post&apos;,&apos;01.php&apos;); /*请求头*/ //get 没有必要设置 //post 必须设置 Content-Type: application/x-www-form-urlencoded xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;); /*请内容*/ /*3.发送请求*/ xhr.send(&quot;name=xjj&amp;age=10&quot;); 7.2.1、请求HTTP请求3个组成部分（请求报文）与XMLHttpRequest方法的对应关系 1、请求行 xhr.open(&apos;post&apos;,&apos;01.php&apos;); 2、请求头 xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;); get请求可以不设置 3、请求主体 xhr.send(&quot;name=xjj&amp;age=10&quot;); get可以传空 注意书写顺序 7.2.2、响应由于服务器做出响应需要时间（比如网速慢等原因），所以我们需要监听服务器响应的状态，然后才能进行处理。 onreadystatechange 监听请求响应事件 readyState 状态 onreadystatechange：是监听XMLHttpRequest的整个请求响应过程中的各个状态 readyState： 记录XMLHttpRequest对象的当前状态 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 if(xhr.readyState == 4 ){ console.log(&apos;响应已完成&apos;); } HTTP响应是由服务端发出的，作为客户端更应关心的是响应的结果。 HTTP响应3个组成部分（响应报文）与XMLHttpRequest方法或属性的对应关系。 1、获取状态行（包括状态码&amp;状态信息） xhr.status 状态码 xhr.statusText 状态码信息 2、获取响应头 xhr.getResponseHeader(&apos;Content-Type&apos;); xhr.getAllResponseHeaders(); 3、响应主体 xhr.responseText xhr.responseXML 我们需要检测并判断响应头的MIME类型后确定使用request.responseText或者request.responseXML 7.3.3、API详解xhr.open() //发起请求，可以是get、post方式 xhr.setRequestHeader() //设置请求头 xhr.send() //发送请求主体，get方式可传null xhr.onreadystatechange = function () {} //监听请求响应过程状态 xhr.readyState //记录请求响应过程状态 xhr.status //表示响应码，如200 xhr.statusText //表示响应信息，如OK xhr.getAllResponseHeaders() //获取全部响应头信息 xhr.getResponseHeader(&apos;key&apos;) //获取指定头信息 xhr.responseText、xhr.responseXML //都表示响应主体 注：GET和POST请求方式的差异（面试题） 1、GET没有请求主体，使用xhr.send(null) 2、GET可以通过在请求URL上添加请求参数 3、POST可以通过xhr.send(‘name=itcast&amp;age=10’) 4、POST需要设置 5、GET效率更好（应用多） 6、GET大小限制约4K，POST则没有限制 问题： 如何获取复杂数据呢？ 开发语言多，各语言变量类型都不一样，需要一种通用的数据格式做信息交换。 XML 和 JSON 就是用来在前后台传输复杂数据。它们特点具有自我描述性（固定的格式的数据） 7.4、 XML什么是 XML? XML 指可扩展标记语言（EXtensible Markup Language） XML 是一种标记语言，很类似 HTML XML 的设计宗旨是传输数据，而非显示数据 XML 标签没有被预定义。您需要自行定义标签。 语法规范： 第一行必须是版本信息 必须有一个根元素（有且仅有一个） 标签不可有空格、不可以数字或.开头、大小写敏感 不可交叉嵌套，都是双标签 属性双引号（浏览器自动修正成双引号了） 特殊符号要使用实体 注释和HTML一样 虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。 xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;array&gt; &lt;item&gt; &lt;src&gt;images/detail01.jpg&lt;/src&gt; &lt;oldPrice&gt;180&lt;/oldPrice&gt; &lt;nowPrice&gt;130&lt;/nowPrice&gt; &lt;/item&gt; &lt;item&gt; &lt;src&gt;images/detail02.jpg&lt;/src&gt; &lt;oldPrice&gt;180&lt;/oldPrice&gt; &lt;nowPrice&gt;120&amp;lt;&amp;gt;&lt;/nowPrice&gt; &lt;/item&gt; &lt;item&gt; &lt;src&gt;images/detail03.jpg&lt;/src&gt; &lt;oldPrice&gt;180&lt;/oldPrice&gt; &lt;nowPrice&gt;110&lt;/nowPrice&gt; &lt;/item&gt; &lt;/array&gt; &lt;!-- 1.第一行必须写xml的头 2.必须有一个根元素 3.标签必须成对出现 4.标签不能以数字开头特殊字符要实，字符实体 --&gt; php: &lt;?php header(&apos;Content-Type:text/xml;charset=utf-8&apos;); /*以xml格式传输数据的时候要求响应内容格式是 text/xml*/ /*file_get_contents 获取文件内容*/ $xml = file_get_contents(&apos;01.data.xml&apos;); /*输出xml内容*/ echo $xml; ?&gt; javascript: var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;,&apos;01.xml_table.php&apos;); xhr.send(null); xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ /*获取的是字符串xhr.responseText*/ // console.log(xhr.responseText); /*获取xml格式文档 xhr.responseXML*/ //console.log(xhr.responseXML); /*把数据添加到页面*/ var html = &apos;&apos;; var items = xhr.responseXML.querySelectorAll(&apos;item&apos;); for(var i=0; i&lt;items.length; i++){ var item = items[i]; var src = item.querySelector(&apos;src&apos;).innerHTML; var oldPrice = item.querySelector(&apos;oldPrice&apos;).innerHTML; var nowPrice = item.querySelector(&apos;nowPrice&apos;).innerHTML; /*拼接模板*/ html += &apos;&lt;tr&gt;&apos;; html += &apos;&lt;td&gt;&apos;+i+&apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos;+src+&apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos;+oldPrice+&apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos;+nowPrice+&apos;&lt;/td&gt;&apos;; html += &apos;&lt;/tr&gt;&apos; } /*添加到表格中*/ document.querySelector(&apos;tbody&apos;).innerHTML = html; } } 7.5、 JSON即 JavaScript Object Notation，另一种轻量级的文本数据交换格式，独立于语言。 1、数据在名称/值对中2、数据由逗号分隔(最后一个健/值对不能带逗号)3、花括号保存对象，方括号保存数组4、键值使用双引号 [ {&quot;src&quot;:&quot;images/detail01.jpg&quot;,&quot;oldPrice&quot;:&quot;10.12&quot;,&quot;newPrice&quot;:&quot;130.00&quot;}, {&quot;src&quot;:&quot;images/detail02.jpg&quot;,&quot;oldPrice&quot;:&quot;1.00&quot;,&quot;newPrice&quot;:&quot;11.00&quot;}, {&quot;src&quot;:&quot;images/detail03.jpg&quot;,&quot;oldPrice&quot;:&quot;100.00&quot;,&quot;newPrice&quot;:&quot;1000.00&quot;} ] JSON数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，需要解析完成后才能读取 1、PHP解析方法 json_encode() ：将php数组、对象转化成json字符 json_decode() ：将json字符转化成php数组、对象 示例代码： &lt;?php header(&apos;Content-Type:text/html;charset=utf-8&apos;); /*以json格式传输数据的时候要求响应内容格式是 application/json*/ /*注意也可以不设置 但是这遵循的一个规范*/ /*file_get_contents 获取文件内容*/ $json = file_get_contents(&apos;01.data.json&apos;); /*输出json内容*/ echo $json; echo &apos;&lt;br&gt;&lt;br&gt;&apos;; $array = array( array(&apos;src&apos;=&gt;&apos;images/detail01.jpg&apos;,&apos;newPrice&apos;=&gt;&apos;12.00&apos;,&apos;oldPrice&apos;=&gt;&apos;455.00&apos;), array(&apos;src&apos;=&gt;&apos;images/detail02.jpg&apos;,&apos;newPrice&apos;=&gt;&apos;65.00&apos;,&apos;oldPrice&apos;=&gt;&apos;878.00&apos;), array( &apos;src&apos;=&gt;&apos;images/detail01.jpg&apos;,&apos;newPrice&apos;=&gt;&apos;100.00&apos;,&apos;oldPrice&apos;=&gt;&apos;1000.00&apos;) ); /*php: json_encode 将php数组转化成json字符*/ $json_array = json_encode($array); echo $json_array; echo &apos;&lt;br&gt;&lt;br&gt;&apos;; /*php: json_decode 将json字符转化成php数组*/ $array_json = json_decode($json_array); echo $array_json; echo &apos;&lt;br&gt;&lt;br&gt;&apos;; ?&gt; 1、Javascript 解析方法 JSON对象 JSON.parse() ：将json格式字符串 转化成 javascript数组、对象 JSON.stringify()：将javascript数组、对象 转化成 json格式字符串 JSON兼容处理json2.js 总结：JSON体积小、解析方便且高效，在实际开发成为首选。 &lt;script&gt; /*声明数组对象*/ var products = [ { src:&apos;images/detail01.jpg&apos;, oldPrice:&apos;120&apos;, nowPrice:&apos;90&apos; }, { src:&apos;images/detail02.jpg&apos;, oldPrice:&apos;120&apos;, nowPrice:&apos;90&apos; }, { src:&apos;images/detail03.jpg&apos;, oldPrice:&apos;120&apos;, nowPrice:&apos;90&apos; } ]; /*javascript: JSON.stringify 将js对象转为json格式字符串*/ var obj2str = JSON.stringify(products) console.log(obj2str); console.log(typeof obj2str); /*javascript: JSON.parse 将js对象转为json格式字符串*/ var str2obj = JSON.parse(obj2str); console.log(str2obj); console.log(typeof str2obj); &lt;/script&gt; 7.6、 兼容性关于IE的兼容方面，了解即可。 function XHR() { var xhr; try { xhr = new XMLHttpRequest(); } /*如果 try内的程序运行错误 抛出异常 捕捉异常 上面程序当中运行的错误*/ catch(e) { /*在不同的IE版本下初始 ActiveXObject 需要传入的标识*/ var IEXHRVers =[&quot;Msxml3.XMLHTTP&quot;,&quot;Msxml2.XMLHTTP&quot;,&quot;Microsoft.XMLHTTP&quot;]; for (var i=0;i&lt;IEXHRVers.length;i++) { try { xhr = new ActiveXObject(IEXHRVers[i]); } catch(e) { /*如果出现错误的时候 停止当次的循环*/ continue; } } } return xhr; } 7.7、 封装ajax工具函数目的：不想做重复的工作，书写重复代码。* 分析使用步骤: 建立XMLHttpRequest对象 使用open方法设置交互的基本信息,打开和服务器连接 使用send方法设置发送，开始和服务器端交互 注册状态监听的onreadystatechange回调函数 封装步骤 步骤1：分析参数（提取会变的为参数） 请求方式 请求地址 是同步还是异步 传递的数据 响应成功处理函数 响应失败的处理函数 步骤2：利用对象优化参数 function ajax(type,url,data,success){ //这种写法不好，参数固定，要记忆参数顺序和类型。不方便后期的使用 console.log(type); console.log(url); } function ajax(options){ // 优势：不再关注参数的顺序，方便参数类型和顺序的扩展 console.log( options.type ); console.log( options.url ); } 步骤3：处理POST与GET差异 POST数据不放在URL上，GET请求数据添加在URL后面 POST请求必须要设置Content-type属性，GET请求则可以省略 POST请求体放在Send方法里。而GET没有请求体可以设为null 步骤4：命名空间使用，不和其他人封装的函数起冲突（被覆盖） 封装过程的演变 /** * 封装ajax工具方法 */ /** * 第1步：分析参数 * * 主要的参数 参数名 类型 默认值 取值范围 * 1.请求方式 type 字符串 get get/post * 2.请求地址 url 字符串 当前地址 后台处理的文件 * 3.传递的数 data 对象 {} {name:jack,age:18} ===&gt; name&amp;jack&amp;age=18 * 4.是否异步 async 布尔值 true true/false * * 响应 * 6.成功回掉 success 函数 - 响应成功后如何处理数据 * 7.失败回掉 error 函数 - 响应失败后如何处理 * */ /** * 第2步：优化传参 * * function ajax(type,url,data,async,success,eror){} 不可取，要记忆参数顺序，调用麻烦 * function ajax(options){} * * var options = { * type:&apos;get&apos;, * url:&apos;xx.php&apos; * success:function(){} * } * * ajax(options) */ /** * 第3步：处理get和post差异，开始封装 */ function ajax(options){ /*如果用户没有传参则返回*/ if(!options || options === {} ){ return false; } /*处理参数为空情况*/ var type = options.type || &apos;get&apos;; var url = options.url || location.pathname; //给当前路径 var data = options.data || {}; var async = options.async === false ? false : true; /*把对象参数转成字符串*/ var dataStr = &apos;&apos;; for( key in data ){ dataStr += key + &quot;=&quot; + data[key] + &quot;&amp;&quot;; } dataStr = dataStr.slice(0,-1); //console.log(dataStr); var xhr = new XMLHttpRequest(); /*处理get和post请求差异*/ if(type === &apos;get&apos;){ xhr.open(type,url + &quot;?&quot; + dataStr ,async); xhr.send(null); } else { xhr.open(type,url,async); xhr.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(dataStr); } /*注册请求响应监听事件*/ xhr.onreadystatechange = function(){ /*响应完成*/ if(xhr.readyState == 4 ){ /*响应成功*/ if(xhr.status == 200 ){ /*根据响应头的content-type属性指定方法接收到的内容*/ var contentType = xhr.getResponseHeader(&apos;content-type&apos;); var data = null; if(contentType.indexOf(&apos;json&apos;) &gt; -1){ data = JSON.parse(xhr.responseText); } else if(contentType.indexOf(&apos;xml&apos;) &gt; -1) { data = xhr.responseXML; } else { data = xhr.responseText; } /*执行成功函数*/ options.success &amp;&amp; options.success(data); } else { /*响应失败*/ options.error &amp;&amp; options.error(xhr.statusText); } } } } /** * 第4步：利用命名空间防止冲突 */ window.itcast = { ajax:function(options){ //console.log(&apos;myajax&apos;); /*如果用户没有传参则返回*/ if(!options || options === {} ){ return false; } /*处理参数为空情况*/ var type = options.type || &apos;get&apos;; var url = options.url || location.pathname; //给当前路径 var data = options.data || {}; var async = options.async === false ? false : true; /*把对象参数转成字符串*/ var dataStr = &apos;&apos;; for( key in data ){ dataStr += key + &quot;=&quot; + data[key] + &quot;&amp;&quot;; } dataStr = dataStr.slice(0,-1); //console.log(dataStr); var xhr = new XMLHttpRequest(); /*处理get和post请求差异*/ if(type === &apos;get&apos;){ xhr.open(type,url + &quot;?&quot; + dataStr ,async); xhr.send(null); } else { xhr.open(type,url,async); xhr.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(dataStr); } /*注册请求响应监听事件*/ xhr.onreadystatechange = function(){ /*响应完成*/ if(xhr.readyState == 4 ){ /*响应成功*/ if(xhr.status == 200 ){ /*根据响应头的content-type属性指定方法接收到的内容*/ var contentType = xhr.getResponseHeader(&apos;content-type&apos;); var data = null; if(contentType.indexOf(&apos;json&apos;) &gt; -1){ data = JSON.parse(xhr.responseText); } else if(contentType.indexOf(&apos;xml&apos;) &gt; -1) { data = xhr.responseXML; } else { data = xhr.responseText; } /*执行成功函数*/ options.success &amp;&amp; options.success(data); } else { /*响应失败*/ options.error &amp;&amp; options.error(xhr.statusText); } } } } } 7.8、 jquery的ajax jQuery为我们提供了更强大的Ajax封装 $.ajax({}) 可配置方式发起Ajax请求 $.get() 以GET方式发起Ajax请求 $.post() 以POST方式发起Ajax请求 $(‘form’).serialize() 序列化表单（即格式化key=val&amp;key=val） 常用参数： url 接口地址 type 请求方式 timeout 请求超时 dataType 服务器返回格式 data 发送请求数据 beforeSend: function () {} 请求发起前调用 success 成功响应后调用 error 错误响应时调用 complete 响应完成时调用（包括成功和失败） jQuery Ajax介绍 http://www.w3school.com.cn/jquery/jquery_ref_ajax.asp 7.9、 案例练习1、Loading状态2、禁止重复提交3、表单处理4、数据验证接口化开发请求地址即所谓的接口，通常我们所说的接口化开发，其实是指一个接口对应一个功能，并且严格约束了请求参数和响应结果的格式，这样前后端在开发过程中，可以减少不必要的讨论，从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口只需要进行微调。 具体参考代码 8、模版引擎8.1、什么是模板引擎？ 一个帮助我们把数据渲染成图形的界面的工具。 假定js中有如下数据： var obj = { name:&quot;大雄&quot;, age:13, skill:&quot;呼叫哆拉A梦&quot; }; 希望渲染为这样的界面： &lt;div&gt;姓名:大雄&lt;/div&gt; &lt;div&gt;年龄:13&lt;/div&gt; &lt;div&gt;技能:呼叫哆拉A梦&lt;/div&gt; 解决办法： 定义这样一个模板，把要显示数据的位置用 部分占位。 写一个函数，读取模板 ===》传入对象===》完成替换===》返回html代码 &lt;div&gt;姓名:{{ name }}&lt;/div&gt; &lt;div&gt;年龄:{{ age }}&lt;/div&gt; &lt;div&gt;技能:{{ skill }}&lt;/div&gt; 常见的模板插件 BaiduTemplate(百度开发) artTemplate(腾讯开发) velocity.js(淘宝开发) Handlebars 模板引擎的用法大同小异,ArtTemplate由于性能优秀,这里我们演示ArtTemplate的用法 8.2、 artTemplate 简介语法模板使用步骤： 1、导入模板引擎: 将下载好的ArtTemplate导入到页面中 &lt;script src=&quot;./js/template.js&quot;&gt;&lt;/script&gt; 2、定义模板: 注意:这路的模板type=’text/html’如果写成javascript会执行 &lt;script id=&quot;template&quot; type=&quot;text/html&quot;&gt; &lt;h2&gt;姓名：{{name}} &lt;/h2&gt; &lt;h2&gt;年龄：{{age}} &lt;/h2&gt; &lt;h2&gt;技能：{{skill}} &lt;/h2&gt; &lt;/script&gt; 3、渲染模板: 我们可以使用template(模板id,数据) 执行替换了; //数据 var data = { name:&apos;小明&apos;, age:18, skill:&apos;快速打代码&apos; }; //模板渲染数据 var tplstr = template(&apos;template&apos;,data); document.querySelector(&apos;div&apos;).innerHTML = tplstr; 模板逻辑语法： each语法: &lt;script src=&quot;./js/template.js&quot;&gt;&lt;/script&gt; &lt;script id=&quot;template&quot; type=&quot;text/html&quot;&gt; {{ each list }} &lt;tr&gt; &lt;td&gt;{{$index+1}}&lt;/td&gt; &lt;td&gt;{{$value.url}}&lt;/td&gt; &lt;td&gt;{{$value.nowPrice}}&lt;/td&gt; &lt;td&gt;{{$value.oldPrice}}&lt;/td&gt; &lt;/tr&gt; {{/each}} &lt;/script&gt; &lt;script&gt; var data = [ { &quot;url&quot;:&quot;images/detail01.jpg&quot;, &quot;nowPrice&quot;:&quot;10.00&quot;, &quot;oldPrice&quot;:&quot;100.00&quot; }, { &quot;url&quot;:&quot;images/detail01.jpg&quot;, &quot;nowPrice&quot;:&quot;10.00&quot;, &quot;oldPrice&quot;:&quot;100.00&quot; }, { &quot;url&quot;:&quot;images/detail01.jpg&quot;, &quot;nowPrice&quot;:&quot;10.00&quot;, &quot;oldPrice&quot;:&quot;100.00&quot; } ]; var html = template(&apos;template&apos;,{list:data}); document.querySelector(&apos;tbody&apos;).innerHTML = html &lt;/script&gt; if 语法: &lt;script src=&quot;./js/template.js&quot;&gt;&lt;/script&gt; &lt;script id=&quot;template&quot; type=&quot;text/html&quot;&gt; &lt;h3&gt;{{name}} {{if isMan }} 兄弟,你好 {{ else }} 妹子,你好 {{/if}} &lt;/h3&gt; &lt;h3&gt;你今天吃益达了嘛。&lt;/h3&gt; &lt;hr&gt; &lt;/script&gt; &lt;script &gt; var person = { name:&apos;小明&apos;, isMan:true }; var person2 = { name:&apos;小红&apos;, isMan:false }; document.querySelector(&apos;input[type=&quot;button&quot;]&apos;).onclick = function(){ var html1 = template(&apos;template&apos;,person); document.querySelector(&apos;#template&apos;).innerHTML = html1; var html2 = template(&apos;template&apos;,person2); document.querySelector(&apos;#template&apos;).innerHTML += html2; } &lt;/script&gt; 8.3、模板引擎实现原理实现方法： 我们定义一段文本作为模板,读取文本,使用特殊的符号占位 通过正则表达式找到这些特殊的符号进行替换,是不是就实现了? 自定义模板引擎 function mytemplate(id,data){ //1.获取模板字符串 var tmpl = document.querySelector(&apos;#&apos;+id).innerHTML; //2.查找里面的字符串 {{}} var re = /{{(\w+)}}/; var result = null; //3.当还有值就替换 while(result = re.exec(tmpl)){ tmpl = tmpl.replace(result[0],data[result[1]]); //替换后重新赋值 } return tmpl } 10、同源&amp;跨域####10.1 同源 什么是同源，同源政策？ 一个网页地址通常有协议，子域名，主域名，端口，请求资源地址，共同组成。 另一个网页，它的协议，子域名，主域名，端口 任何一个不一样，则称两个网页不在同一个域即不同源。 在不同源的两个页面之间，浏览器默认会有一些限制。我们称之为同源政策。 而突破绕过这些限制，在两个页面之间进行访问，我们称为跨域访问。 同源：是指两个网页，域名，协议，端口完全相同。 同源政策：是浏览器的一种安全策略，当两个网页，域名，协议，端口任何一个不同时，就会受到一些限制。 同源政策目的：是为了保证用户信息的安全，防止恶意的网站窃取数据。 限制范围： 无法共享 cookie, localStorage, indexDB 无法操作彼此的 dom 元素 无法发送 ajax 请求 无法通过 flash 发送 http 请求 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 信息，会发生什么？ 网页A网址： http://www.example.com/index.html 网页B地址： http://www.example.com/detail.html 同源 http://www.example.com/detail/index.html 同源 （只是目录不同） http://api.example.com/detail.html 不同源（域名不同） https//www.example.com/detail.html 不同源（协议不同） http://www.example.com:8080/detail.html 不同源（端口不同） http://mp.example.com/detail.html 不同源（子域不同） http://70.32.92.74.com/detail.html 不同源（域名对应ip） https://www.example.com:8080/detail.html 不同源（端口、协议不同） ####10.2 跨域 同源策略做了很严格的限制，但是在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域 跨域：不同源访问，则是跨域 网页A网址： http://www.example.com/index.html 访问网页B： http://www.baidu.com/server.php 跨域（域名不同） http://api.example.com/server.php 跨域（子域不同） https//www.example.com/server.php 跨域（协议不同） http://www.example.com:8080/server.php 跨域（端口不同） http://192.168.10.78.com/server.php 跨域（域名对应ip） 可跨域的标签link,iframeimgscript 10.4、 jsonp JSON with Padding 1、原理剖析 其本质是利用了标签具有可跨域的特性，由服务端返回一个预先定义好的Javascript函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。 html页面： &lt;!-- 当我们用script标签去加载的时候 会把内容解析成js去执行 --&gt; &lt;script&gt; //1.我们先定义一个函数 function myfoo( jsonpData ){ //内部如何使用就是我们自己定的了。 console.log(jsonpData); } &lt;/script&gt; &lt;!-- 2.利用script标签的src属性请求并执行调用--&gt; &lt;script src=&quot;http://api.study.php?callback=myfoo&quot;&gt;&lt;/script&gt; 后台php页面： &lt;?php //接收传递过来的函数名 $name = $_GET[&apos;callback&apos;]; //转为数组为json格式数据 $arr = array(&quot;小李飞&quot;,&quot;大张伟&quot;); $jsonData = json_encode($arr); //返回函数名称的调用。 echo $name.&quot;(&quot;.$jsonData.&quot;)&quot;; ?&gt; ####10.4 CORS 服务端设置响应头： header(‘Access-Control-Allow-Origin: *’);实现跨域 html页面： //在jquery中跨域 $.ajax({ type:&apos;post&apos;, url:&apos;http://api.study.com/post.php&apos;, data:{ name:&apos;汤姆&apos; }, dataType:&apos;json&apos;, success:function(data){ console.log(data); } }) 后台php页面 /*允许所有的跨域请求*/ //header(&apos;Access-Control-Allow-Origin:*&apos;); /*也可以显示某一个具体的来源可以访问*/ header(&apos;Access-Control-Allow-Origin:http://www.study.com&apos;); $arr = array( &apos;name&apos;=&gt;$_POST[&apos;name&apos;] ); echo json_encode($arr); 优点： get 和 post请求都能发送 ####10.3 跨域方案（课外拓展） 以下方式基本不用啊，了解即可： 1、顶级域名相同的可以通过domain.name来解决，即同时设置 domain.name = 顶级域名（如example.com）2、document.domain + iframe3、window.name + iframe4、location.hash + iframe5、window.postMessage() 参考资料http://rickgray.me/2015/09/03/solutions-to-cross-domain-in-browser.html 11、综合案例11.1、瀑布流案例（必须掌握）什么是瀑布流？ 就是一种常见的网页布局的方式，比如花瓣网所采用的。 布局特点： 1、图文元素按列排放。 2、每列内容宽度一致，但高度不同。 3、第一行顶部对象。后面内容受首行高度影响。错落排放。 4、滚动到底部就会优先向最短的列添加数据。 瀑布流核心: 1、 宽度一致,高度参差不齐 2、新增行的内容,优先添加到最矮的列 11.2、天气接口（必须掌握）接口地址 url: &apos;http://api.map.baidu.com/telematics/v3/weather?location=%E5%B9%BF%E5%B7%9E&amp;output=json&amp;ak=FK9mkfdQsloEngodbFl4FeY3&apos;,]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js高级</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MARKDOWN基本语法]]></title>
    <url>%2F2015%2F09%2F15%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本符号*,-,+ 3个符号效果都一样，这3个符号被称为 Markdown符号 空白行表示另起一个段落 `是表示inline代码，tab是用来标记 代码段，分别对应html的code，pre标签 换行单一段落用一个空白行 连续两个空格 会变成一个 &lt;br&gt; 连续3个符号，然后是空行，表示 hr 横线 标题生成h1–h6,在文字前面加上 1–6个# 来实现 文字加粗是通过 文字左右各两个符号 引用在第一行加上 “&gt;”和一个空格，表示代码引用，还可以嵌套 列表这个是markdown文件的主要表示方式，主题要点化 使用*,+,-加上一个空格来表示 可以支持嵌套 有序列表用 数字+英文点+空格来表示 列表内容很长，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的 链接直接写 锚文本 引用 先定义 [ref_name]:url，然后在需要写入url的地方， 这样使用[锚文本][ref_name]，通常的ref_name一般用数字表示，这样显得专业 简写url：用尖括号包裹url 这样生成的url锚文本就是url本身 插入图片一行表示: 引用表示法: ![alt_text][id],预先定义 [id]:url “可选title” 直接使用标签，这样可以指定图片的大小尺寸 特殊符号用\来转义，表示文本中的markdown符号 可以在文本种直接使用html标签，但是要注意在使用的时候，前后加上空行 文本前后各加一个符号，表示斜体]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>MARKDOWN</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串方法]]></title>
    <url>%2F2015%2F08%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、charAt() 作用：根据下标找对应的字符 语法：string.charAt(n); 参数：n (可不写,默认为0) 返回值：字符串string的第n个字符。 若n不在0~string.length-1范围内，返回 “” 12345678举例：var str = &quot;hello&quot;;//无参数（默认为0）str.charAt();//h//在范围的参数str.charAt(1);//e//不在范围的参数str.charAt(100);//&quot;&quot; 2、charCodeAt() 作用：根据下标找对应的字符 语法：string.charCodeAt(n); 参数：n (可不写,默认为0) 返回值：返回字符串中第ｎ个字符串在Unicode中的编码 若n不在0~string.length-1范围内，返回NaN。12345678举例：var str = &quot;hello&quot;;//无参数（默认为0）str.charCodeAt();//104//在范围内的参数str.charCodeAt(1);//101//不在范围内的参数str.charCodeAt(100);//NaN 3、fromCharCode() 作用：根据字符编码找对应字符 语法：string.fromCharCode(n1,n2…) 参数：n1、n2…（字符编码） 返回值：含有指定编码的字符的新字符串 注意点：fromcharCode()是构造函数 String()的属性，而不是字符串或String对象的方法。123举例：var str = String.fromCharCode(104, 101, 108, 108, 111);console.log(str);//hello 4、indexOf() 作用：根据字符找下标 语法：string.indexOf(str，n) 参数：str - 要在字符串string中检索的子串 n - 开始检索的位置 可不写，默认为0 返回值：返回第一个出现str的第一个字符在string中的位置,要完整包含，否则返回-1 若没有，返回-1123456举例：var str = &quot;hello&quot;;//无参数str.indexOf();//-1//只有一个参数n （默认为0）str.indexOf(&quot;h&quot;);//0 5、lastIndexOf() 作用：根据字符找下标，从后往前找 语法：string.lastIndexOf(str，n) 参数：str - 要在字符串string中检索的子串 n - 开始检索的位置 可不写，默认为0 返回值：返回第一个出现str的第一个字符在string中的位置,要完整包含，否则返回-1 若没有，返回-11举例： 6、toUpperCase() 作用:将小写字母转成大写 语法：string.toUpperCase() 参数：无参数 返回值：将所有小写字符都被转换成了大写字符 后的string 原字符串：不变12345举例：var str = hello;var str1 = str.toUpperCase();console.log(str);console.log(str1); 7、toLowerCase() 作用:将大写字母转成小写 语法：string.toLowerCase() 参数：无参数 返回值：将所有大写字符都被转换成了小写字符 后的string 原字符串：不变1举例： 8、slice() 作用:用于截取字符串，返回新的截取后的字符串 语法：string.slice(start,end) 参数：start - 开始截取的下标 end - 结束截取的下标(不包含结束位置) 如果是负数，从尾部位置开始算起 返回值：截取后新的字符串 原字符串：不变1举例： 9、substring() 作用:用于截取字符串，返回新的截取后的字符串 语法：string.subString(from,to) 参数：from - 开始截取的位置 to - 结束截取的位置（不包含结束的位置） to 可省略，默认到字符串结尾位置 返回值：截取的新的字符串 若from = to 返回 “” 若from &gt; to 先交换参数位置，但包含的还是from, 不包含to 原字符串：不变1举例： 10、split() 作用:将字符串用分隔符转成数组 语法：string.split(a,limit) 参数：a - 字符串或正则表达式,从该参数指定的地方分割string limit - 指定了返回的数组的最大长度(可不写) 返回值：一个字符串数组 若 a 在 string 开头位置，返回的数组的第一个元素是空字符串 若 a 在 string 结尾位置，返回的数组的最后一个元素是空字符串 原字符串：不变1举例：]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值类型和引用类型]]></title>
    <url>%2F2015%2F07%2F11%2F%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[值类型和引用类型1.值类型(基本数据类型) 数值类型 布尔类型 undefined null 字符串 值类型是存储在栈（stack）中的简单数据，也就是说，它们的值直接存储在变量访问的位置。 12345var num = 10;var str = "hello JS";var flag = true;var un = undefined;var nu = null; 上面定义的这些值类型的数据在内存中的存储如下 2.引用类型(复合数据类型) 对象 数组 函数 存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。 1234567891011121314151617181920212223242526272829var arr = [1, 2, 3];var p1 = &#123;name:"张三", age:18&#125;;var p2 = &#123; name:"李四", age:50, son:&#123; name:"李小一", age:18 &#125;&#125;;var p3 = &#123; name:"王五", age:50, children:[ &#123; name:"王小一", age:20 &#125;, &#123; name:"王小二", age:15 &#125;, &#123; name:"王小三", age:12 &#125; ]&#125; 上面定义的这些引用类型的数据在内存中的存储如下]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值类型和引用类型的特征]]></title>
    <url>%2F2015%2F07%2F11%2F%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[1. 值类型和引用类型的赋值1.1. 值类型赋值，直接将值复制一份12var num1 = 10;var num2 = num1; 上面两句代码，在内存中的体现为： var num1 = 10;表示变量num1存储的是数字10 将数据拷贝一份，也就是将10拷贝一份，这个时候内存中有两个10 将拷贝的10赋值给num2 1.2. 引用类型赋值，是将地址复制一份 12var p = &#123;name:"张三", age:19&#125;;var p1 = p; 上面两句代码，在内存中的体现为： var p = {name:&quot;张三&quot;, age:19};,p中存储的是对象的地址 赋值就是将变量p中存储的数据，也就是地址拷贝一份, 然后将该数据赋值给p1 此时内存中只有 1 个对象，变量p和p1同时指向这个对象 问题: 利用p1修改的name属性会影响到p中的name 2. 值类型和引用类型做参数考虑如下情况：输出结果是多少？1234567function foo(num)&#123; num++;&#125;var a = 1;foo(a);console.log(a); 继续考虑如下情况：输出结果是多少？ 123456789function foo(o)&#123; o.age++;&#125;var p = &#123;name:"张三", age:19&#125;;foo(p);console.log(p.age); 总结： 在调用函数的时候，传参的过程其实就是用实参给形参赋值的过程 当参数为值类型的时候，函数内和函数外的两个变量完全不同，仅仅只是存的值一样而已，修改时互不影响 当参数为引用类型的时候，函数内和函数外的两个变量不同，但是共同指向同一个对象，在函数内修改对象数据时会影响外部 扩展： 考虑如下情况：输出结果是多少？ 123456789function foo(o)&#123; o = &#123;name:"张三", age:18&#125;;&#125;var p;foo(p);console.log(p.age);]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5]]></title>
    <url>%2F2015%2F07%2F10%2Fhtml5%2F</url>
    <content type="text"><![CDATA[关于HTML5起步HTML5 是 W3C 与 WHATWG 合作的结果,WHATWG 指 Web Hypertext Application Technology Working Group。WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。 简介HTML5 是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。 HTML5 的设计目的是为了在移动设备上支持多媒体。 HTML5 简单易学。 理解对比之前的html版本html到底有那些增强？什么是html5？ 我们日常讨论的H5其实指的是一个范称，它是由HTML5 + CSS3 + Javascript等技术组合而成的一个应用开发平台。 html 提升文档声明&lt;!doctype&gt; 声明必须位于 HTML5 文档中的第一行,使用非常简单:1&lt;!DOCTYPE html&gt; 文档骨架12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文档内容...... &lt;/body&gt;&lt;/html&gt; 注意： 申明文档语言 声明编码，中文否则会出现乱码。 特点：结构简洁，语法宽松。 W3C验证地址 https://validator.w3.org/ 标签语义标签 标签 解释 header 定义了文档的头部区域 nav 定义导航链接的部分。 section 定义文档中的节（section、区段）。 article 定义页面独立的内容区域。 aside 定义页面的侧边栏内容。 figure 规定独立的流内容（图像、图表、照片、代码等等）。 figcaption 定义 figure 元素的标题 dialog 定义对话框，比如提示框 footer 定义 section 或 document 的页脚。 —- —- bdi 允许您设置一段文本，使其脱离其父元素的文本方向设置。 command 定义命令按钮，比如单选按钮、复选框或按钮 details 用于描述文档或文档某个部分的细节 summary 标签包含 details 元素的标题 mark 定义带有记号的文本。 meter 定义度量衡。仅用于已知最大和最小值的度量。 progress 定义任何类型的任务的进度。 ruby 定义 ruby 注释（中文注音或字符）。 rt 定义字符（中文注音或字符）的解释或发音。 rp 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 time 定义日期或时间。 wbr 规定在文本中的何处适合添加换行符。 经典网页布局传统版123456789101112131415&lt;body&gt; &lt;!-- 头部 --&gt; &lt;div class="header"&gt; &lt;ul class="nav"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;!-- 主体部分 --&gt; &lt;div class="main"&gt; &lt;!-- 文章 --&gt; &lt;div class="article"&gt;&lt;/div&gt; &lt;!-- 侧边栏 --&gt; &lt;div class="aside"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 底部 --&gt; &lt;div class="footer"&gt;&lt;/div&gt;&lt;/body&gt; 经典网页布局HTML5版123456789101112131415&lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt; &lt;nav class="nav"&gt;&lt;/nav&gt; &lt;/header&gt; &lt;!-- 主体部分 --&gt; &lt;main class="main"&gt; &lt;!-- 文章 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 侧边栏 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;!-- 底部 --&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt; 本质上新语义标签与div、span没有区别，只是其具有表意性。使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别。可以理解成&lt;div class=”nav”&gt; 相当于 &lt;nav&gt;,不要好奇，它只是一个标签！注意：尽量避免全局使用header、footer、aside等语义标签。 兼容处理越来越多的站点开始使用 HTML5 标签。但情况是还有很多人在使用IE6，IE7，IE8。 在不支持HTML5新标签的浏览器里，会将这些新的标签解析成行内元素(inline)对待， 所以我们只需要将其转换成块元素(block)即可使用， 但是在IE9版本以下，并不能正常解析这些新标签， 但是却可以识别通过document.createElement(‘tagName’)创建的自定义标签， 于是我们的解决方案就是将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍， 这样IE低版本也能正常解析HTML5新标签了， 在实际开发中我们更多采用的是通过检测IE浏览器的版本来加载第三方的一个JS库来解决兼容问题。 html5shiv123&lt;!--[if lt IE 9]&gt;&lt;script type="text/javascript" src="js/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 下载地址 http://www.bootcdn.cn/html5shiv/ 案例练习博客文章 表单输入类型HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。本章全面介绍这些新的输入类型： 类型 说明 email 在提交表单时，会自动验证 email 域的值是否合法有效 url 定义输入URL字段,在提交表单时，会自动验证 url 域的值 tel 定义输入电话号码字段 number 定义一个数值输入域(限定):max- 规定允许的最大值min - 规定允许的最小值step - 规定合法的数字间隔（如果 step=”3”，则合法的数是 -3,0,3,6 等）value - 规定默认值 search 定义一个搜索字段 (类似站点搜索或者Google搜索) —- —- range 定义一个不需要非常精确的数值（类似于滑块控制）:max- 规定允许的最大值min - 规定允许的最小值step - 规定合法的数字间隔（如果 step=”3”，则合法的数是 -3,0,3,6 等）value - 规定默认值 color 从拾色器中选择一个颜色 time 定义可输入时间控制器 date 定义一个时间控制器 week 定义周和年 month 定义月与年 datetime 定义一个日期和时间控制器 兼容性差 datetime-local 定义一个日期和时间 注意:并不是所有的主流浏览器都支持新的input类型，不过您已经可以在所有主流的浏览器中使用它们了。即使不被支持，仍然可以显示为常规的文本域。部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。 虚拟键盘调用123456&lt;input type="text" name="txt_text" id="txt_text"&gt;&lt;input type="number" name="txt_number" id="txt_number"&gt;&lt;input type="email" name="txt_email" id="txt_email"&gt;&lt;input type="tel" name="txt_tel" id="txt_tel"&gt;&lt;input type="url" name="txt_url" id="txt_url"&gt;&lt;input type="search" name="txt_search" id="txt_search"&gt; 在移动端虚拟键盘会有搜索按钮 表单标签datalist 元素规定输入域的选项列表。 123456789&lt;input list="browsers"&gt;&lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt;&lt;/datalist&gt; keygen 生成加密字符串 当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。 12345&lt;form action="keygen.do" method="get"&gt;用户名: &lt;input type="text" name="usr_name"&gt;加密: &lt;keygen name="security"&gt;&lt;input type="submit"&gt;&lt;/form&gt; output 元素用于不同类型的输出,不可当做数据提交 12345&lt;form oninput="x.value=parseInt(a.value)+parseInt(b.value)"&gt;0&lt;input type="range" id="a" value="50"&gt;100 +&lt;input type="number" id="b" value="50"&gt;=&lt;output name="x" for="a b"&gt;&lt;/output&gt;&lt;/form&gt; 表单属性 form autocomplete 设置整个表单是否开启自动完成 on|off novalidate 设置H5的表单校验是否工作 true 不工作 不加该属性代表校验 input: autocomplete 单独设置每个文本框的自动完成 autofocus 设置当前文本域页面加载完了过后自动得到焦点 list 作用就是指定当前文本框的自动完成列表的数据 datalist 在界面上是看不见的，只是用于定义数据列表的 multiple 文本域的多选 pattern 设置文本框的匹配格式（正则） placeholder 文本框占位符 required 限制当前input为必须的 form 属性是让表单外的表单元素也可以跟随表单一起提交 submit: form 在submit上重写表单的特定属性，当点击当前submit时会以当前值使用 formaction, formenctype, formmethod, formnovalidate, formtarget 表单事件 oninput 用户输入内容时触发，可用于移动端输入字数统计 oninvalid 验证不通过时触发， setCustomValidity 设置自定义提示 (验证通过需要本身合法并且没有提示信息) 案例练习学生档案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;form action=""&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案&lt;/legend&gt; &lt;label&gt; 姓名: &lt;input type="text" pattern="&#123;6,10&#125;" name="username" placeholder="请输入姓名" id="username" required autofocus &gt; &lt;/label&gt; &lt;label&gt; 手机号码: &lt;input type="text" name="mobile" placeholder="请输入手机号" required pattern="^1\d&#123;10&#125;$" &gt; &lt;/label&gt; &lt;label&gt; 邮箱地址: &lt;input type="email" name="email" placeholder="请输入邮箱地址" required &gt; &lt;/label&gt; &lt;label&gt; 所属学院: &lt;input type="text" name="course" list="course" placeholder="请输入所属学院" &gt; &lt;datalist id="course"&gt; &lt;option value="前端与移动开发"&gt;&lt;/option&gt; &lt;option value="PHP"&gt;&lt;/option&gt; &lt;option value="JAVA"&gt;&lt;/option&gt; &lt;option value="Android"&gt;&lt;/option&gt; &lt;option value="IOS"&gt;&lt;/option&gt; &lt;option value="UI设计"&gt;&lt;/option&gt; &lt;option value="C++"&gt;&lt;/option&gt; &lt;/datalist&gt; &lt;/label&gt; &lt;label&gt; 入学成绩: &lt;input id="score" name="score" type="number" min="0" max="100" step="10" value="60"/&gt; &lt;/label&gt; &lt;label&gt; 基础水平: &lt;meter id="level" name="level" min="0" max="100" low="60" high="80" value="70"&gt;&lt;/meter&gt; &lt;/label&gt; &lt;label&gt; 入学日期: &lt;input type="date" value="2016-07-03"&gt; &lt;/label&gt; &lt;label&gt; 毕业时间: &lt;input type="date" value="2016-11-03"&gt; &lt;/label&gt; &lt;label&gt; 课程进度: &lt;progress max="100" value="30"&gt;&lt;/progress&gt; &lt;/label&gt; &lt;input type="submit" value="保存"/&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;script&gt; /*获取到姓名元素*/ var username = document.getElementById("username"); /*如果有提示内容 也会触发这个事件*/ username.oninvalid = function()&#123; console.log('oninvalid'); &#125;; /*动态的展示入学成绩的水平*/ /*获取到入学成绩这个元素*/ var scoreInput = document.getElementById('score'); /*水平元素*/ var levelMeter = document.getElementById('level'); /*监听score的值的改变*/ scoreInput.oninput = function()&#123; /*怎么样让水平状态改变*/ levelMeter.value = this.value; &#125;&lt;/script&gt; 多媒体音频 定义音频播放组件 1&lt;audio src="要播放的音频文件"&gt;&lt;/audio&gt; 视频 定义播放视频组件 1&lt;video src="要播放的视频文件"&gt;&lt;/video&gt; 旧版本浏览器提示 如果HTML中遇到不能识别的标签，就会将该标签当做DIV(块级元素) 那么video中的innerHTML也就会直接显示在界面上 利用这个特点我们可以实现不支持video标签的浏览器提示 1234&lt;video src="demo.mp4"&gt; &lt;!-- 如果浏览器不识别video标签，以下内容可以直接显示在浏览器上 --&gt; &lt;p&gt;抱歉，您的浏览器不支持视频播放！&lt;/p&gt;&lt;/video&gt; 格式兼容 每个浏览器的音视频格式支持不同（版权问题） 需要兼容更多的浏览器，可以通过定义多个&lt;source&gt;的方式实现 html解析过程中会找其中第一个能认识的格式播放，一旦找到认识的视频格式，就不会再往后找了 1234567891011&lt;!-- 分析第一个source格式是否支持，如果支持则加载该文件，不支持继续往下解析 --&gt;&lt;source src="See You Again.mp3"/&gt;&lt;source src="See You Again.wav"/&gt;&lt;source src="See You Again.ogg"/&gt;&lt;p&gt;抱歉，您的浏览器不支持音频播放！&lt;/p&gt;&lt;!-- 分析第一个source格式是否支持，如果支持则加载该文件，不支持继续往下解析 --&gt;&lt;source src="chrome.mp4"&gt;&lt;source src="chrome.ogv"&gt;&lt;source src="chrome.webm"&gt;&lt;p&gt;抱歉，您的浏览器不支持视频播放！&lt;/p&gt; 因此不管是audio还是video都不要直接设置标签的src 多媒体属性 属性 含义 controls 决定是否显示控制菜单 autoplay 自动播放 loop 循环播放 height/width 定义播放器的宽高，只会在视频标签中生效 preload 预加载 是否在页面加载完成并且没有开始播放时就开始加载文件，如果有自动播放属性则该属性无意义 自定义控制栏 隐藏原生的控制菜单，也就是删除标签中的controls属性 自己设计一套界面控制元素，比如播放按钮，音量控制开关之类 为每个不同的控制元素注册对应的事件 在事件中通过视频元素的API实现自定义播放器的效果 具体的多媒体元素API表： 方法 方法 描述 addTextTrack() 向音频/视频添加新的文本轨道 canPlayType() 检测浏览器是否能播放指定的音频/视频类型 load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 属性 属性 描述 audioTracks 返回表示可用音轨的 AudioTrackList 对象 autoplay 设置或返回是否在加载完成后随即播放音频/视频 buffered 返回表示音频/视频已缓冲部分的 TimeRanges 对象 controller 返回表示音频/视频当前媒体控制器的 MediaController 对象 controls 设置或返回音频/视频是否显示控件（比如播放/暂停等） crossOrigin 设置或返回音频/视频的 CORS 设置 currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） defaultMuted 设置或返回音频/视频默认是否静音 defaultPlaybackRate 设置或返回音频/视频的默认播放速度 duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 error 返回表示音频/视频错误状态的 MediaError 对象 loop 设置或返回音频/视频是否应在结束时重新播放 mediaGroup 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） muted 设置或返回音频/视频是否静音 networkState 返回音频/视频的当前网络状态 paused 设置或返回音频/视频是否暂停 playbackRate 设置或返回音频/视频播放的速度 played 返回表示音频/视频已播放部分的 TimeRanges 对象 preload 设置或返回音频/视频是否应该在页面加载后进行加载 readyState 返回音频/视频当前的就绪状态 seekable 返回表示音频/视频可寻址部分的 TimeRanges 对象 seeking 返回用户是否正在音频/视频中进行查找 src 设置或返回音频/视频元素的当前来源 startDate 返回表示当前时间偏移的 Date 对象 textTracks 返回表示可用文本轨道的 TextTrackList 对象 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象 volume 设置或返回音频/视频的音量 事件 事件 描述 abort 当音频/视频的加载已放弃时 canplay 当浏览器可以播放音频/视频时 canplaythrough 当浏览器可在不因缓冲而停顿的情况下进行播放时 durationchange 当音频/视频的时长已更改时 emptied 当目前的播放列表为空时 ended 当目前的播放列表已结束时 error 当在音频/视频加载期间发生错误时 loadeddata 当浏览器已加载音频/视频的当前帧时 loadedmetadata 当浏览器已加载音频/视频的元数据时 loadstart 当浏览器开始查找音频/视频时 pause 当音频/视频已暂停时 play 当音频/视频已开始或不再暂停时 playing 当音频/视频在已因缓冲而暂停或停止后已就绪时 progress 当浏览器正在下载音频/视频时 ratechange 当音频/视频的播放速度已更改时 seeked 当用户已移动/跳跃到音频/视频中的新位置时 seeking 当用户开始移动/跳跃到音频/视频中的新位置时 stalled 当浏览器尝试获取媒体数据，但数据不可用时 suspend 当浏览器刻意不获取媒体数据时 timeupdate 当目前的播放位置已更改时 volumechange 当音量已更改时 waiting 当视频由于需要缓冲下一帧而停止 DOM扩展获取元素1、document.getElementsByClassName (‘class’) 通过类名获取元素，以类数组形式存在。 2、document.querySelector(‘selector’) 通过CSS选择器获取元素，符合匹配条件的第1个元素。 3、document.querySelectorAll(‘selector’) 通过CSS选择器获取元素，以类数组形式存在。 类名操作1、Node.classList.add(‘class’) 添加class 2、Node.classList.remove(‘class’) 移除class 3、Node.classList.toggle(‘class’) 切换class，有则移除，无则添加 4、Node.classList.contains(‘class’) 检测是否存在class Node指一个有效的DOM节点，是一个通称。 自定义属性在HTML5中我们可以自定义属性，其格式如下data-*=””，例如 data-info=”我是自定义属性”，通过Node.dataset[‘info’] 我们便可以获取到自定义的属性值。 Node.dataset是以类数组形式存在的 当我们如下格式设置时，则需要以驼峰格式才能正确获取 data-my-name=”itcast”，获取Node.dataset[‘myName’] 案例练习Tab切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Tab 标签&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #F7F7F7; &#125; .tabs &#123; width: 400px; margin: 30px auto; background-color: #FFF; border: 1px solid #C0DCC0; box-sizing: border-box; &#125; .tabs nav &#123; height: 40px; text-align: center; line-height: 40px; overflow: hidden; background-color: #C0DCC0; display: flex; &#125; nav a &#123; display: block; width: 100px; border-right: 1px solid #FFF; color: #000; text-decoration: none; &#125; nav a:last-child &#123; border-right: 0 none; &#125; nav a.active &#123; background-color: #9BAF9B; &#125; .cont &#123; overflow: hidden; display: none; &#125; .cont ol &#123; line-height: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="tabs"&gt; &lt;nav&gt; &lt;a href="javascript:;" data-cont="local"&gt;国内新闻&lt;/a&gt; &lt;a href="javascript:;" data-cont="global"&gt;国际新闻&lt;/a&gt; &lt;a href="javascript:;" data-cont="sports"&gt;体育新闻&lt;/a&gt; &lt;a href="javascript:;" data-cont="funny"&gt;娱乐新闻&lt;/a&gt; &lt;/nav&gt; &lt;section class="cont" id="local"&gt; &lt;ol&gt; &lt;li&gt;河感在生矿难，死伤在全10&lt;/li&gt; &lt;li&gt;禽流感在感在广1处继续蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广在全国暴发&lt;/li&gt; &lt;li&gt;禽流感在全国多处继续蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class="cont" id="global"&gt; &lt;ol&gt; &lt;li&gt;河南再次发生矿难，死伤人数超过100&lt;/li&gt; &lt;li&gt;禽流感次发生蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广减产绝收发&lt;/li&gt; &lt;li&gt;禽流感在全国多作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class="cont" id="sports"&gt; &lt;ol&gt; &lt;li&gt;河南再次发生矿难，死伤人数超过100&lt;/li&gt; &lt;li&gt;禽流感在全国多处农作物农延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;li&gt;禽流感在全农作物继续蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class="cont" id="funny"&gt; &lt;ol&gt; &lt;li&gt;河南再次发生矿难，死伤人数超过101 &lt;/li&gt; &lt;li&gt;禽流感在全国多处农作物农延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大旱，农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;li&gt;禽流感在全农作物继续蔓延，温家宝指示&lt;/li&gt; &lt;li&gt;南方大农作物减产绝收面积上亩&lt;/li&gt; &lt;li&gt;猪流感在广东群体性暴发&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;/div&gt; &lt;script&gt; /* * 1.页面初始化的时候可以指定当前选择的页签 * 2.点击页签的时候可以做到样式的切换 * 3.点击的时候可以让对应的内容 做对应的显示 * */ /*function tab(index)&#123; /!*---*!/ &#125; tab(0);*/ (function(index)&#123; var tabList = document.querySelectorAll('nav &gt; a'); var sectionList = document.querySelectorAll('section'); for(var i = 0 ; i &lt; tabList.length ; i++)&#123; var tab = tabList[i]; /*1.页面初始化的时候可以指定当前选择的页签*/ tab.classList.remove('active'); if(index == i)&#123; tab.classList.add('active'); document.querySelector('#'+tab.dataset['cont']).style.display = "block"; &#125; /*2.点击页签的时候可以做到样式的切换*/ tab.onclick = function()&#123; if(this.classList.contains('active'))&#123; return false; &#125; for(var j = 0 ; j &lt; tabList.length ; j++)&#123; tabList[j].classList.remove('active'); &#125; this.classList.add('active'); for(var k = 0 ; k &lt; sectionList.length ; k ++)&#123; sectionList[k].style.display = 'none'; &#125; document.querySelector('#'+this.dataset['cont']).style.display = 'block'; &#125; &#125; &#125;)(0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2015%2F06%2F27%2FjQuery%2F</url>
    <content type="text"><![CDATA[jQuery1. jQuery基本概念 学习目标：学会如何使用jQuery，掌握jQuery的常用api，能够使用jQuery实现常见的效果。 1.1 为什么要学习jQuery？【01-让div显示与设置内容.html】 使用javascript开发过程中，有许多的缺点： 123451. 查找元素的方法太少，麻烦。2. 遍历伪数组很麻烦，通常要嵌套一大堆的for循环。3. 有兼容性问题。4. 想要实现简单的动画效果，也很麻烦5. 代码冗余。 1.2 jQuery初体验【02-让div显示与设置内容.html】 12345678910$(document).ready(function () &#123; $("#btn1").click(function () &#123; //隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。 $("div").show(200); &#125;); $("#btn2").click(function () &#123; $("div").text("我是内容"); &#125;);&#125;); 优点总结：123451. 查找元素的方法多种多样，非常灵活2. 拥有隐式迭代特性，因此不再需要手写for循环了。3. 完全没有兼容性问题。4. 实现动画非常简单，而且功能更加的强大。5. 代码简单、粗暴。 没有对比，就没有伤害，有了对比，处处戳中要害。 1.3 什么是jQuery? jQuery的官网 http://jquery.com/ jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。 js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js、common.js） 我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。 1.4 jQuery的版本 官网下载地址：http://jquery.com/download/ jQuery版本有很多，分为1.x 2.x 3.x 大版本分类： 123451.x版本：能够兼容IE678浏览器2.x版本：不兼容IE678浏览器1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。3.x版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678） 关于压缩版和未压缩版 12jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。 1.5 jQuery的入口函数使用jQuery的三个步骤：1231. 引入jQuery文件2. 入口函数3. 功能实现 关于jQuery的入口函数：12345678//第一种写法$(document).ready(function() &#123;&#125;);//第二种写法$(function() &#123;&#125;); jQuery入口函数与js入口函数的对比121. JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。2. jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。 1.6 jQuery对象与DOM对象的区别（重点）12341. DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。2. jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。3. jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合（伪数组））4. DOM对象与jQuery对象的方法不能混用。 DOM对象转换成jQuery对象：【联想记忆：花钱】12var $obj = $(domObj);// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象 jQuery对象转换成DOM对象：12345var $li = $(“li”);//第一种方法（推荐使用）$li[0]//第二种方法$li.get(0) 练习：隔行变色案例.html】 2. 选择器2.1 什么是jQuery选择器jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。 jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。【查看jQuery文档】 jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。 2.2 基本选择器 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 使用逗号分隔，只要符合条件之一就可 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 总结：跟css的选择器用法一模一样。 2.3 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 跟CSS的选择器一模一样。 2.4 过滤选择器 注意: 这类选择器都带冒号: 名称 用法 描述 :eq（index） $(“li:eq(2)”).css(“color”, ”red”); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始 :odd $(“li:odd”).css(“color”, ”red”); 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”).css(“color”, ”red”); 获取到的li元素中，选择索引号为偶数的元素 【案例：隔行变色】 2.5 筛选选择器(方法) 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。 名称 用法 描述 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，子类选择器 find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“#first”).siblings(“li”); 查找兄弟节点，不包括自己本身。 parent() $(“#first”).parent(); 查找父亲 eq(index) $(“li”).eq(2); 相当于$(“li:eq(2)”),index从0开始 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 1234【案例：下拉菜单】this+children+mouseenter+mouseleave【案例：突出展示】siblings+find【案例：手风琴】next+parent【案例：淘宝精品】index+eq 3. jQuery操作样式3.1 行内css样式操作 功能：设置或者修改样式，操作的是style属性。 操作单个样式 12345//name：需要设置的样式名称//value：对应的样式值css(name, value);//使用案例$("#one").css("background","gray");//将背景色修改为灰色 设置多个样式 12345678//参数是一个对象，对象中包含了需要设置的样式名和样式值css(obj);//使用案例$("#one").css(&#123; "background":"gray", "width":"400px", "height":"200px"&#125;); 获取样式 1234//name:需要获取的样式名称css(name);//案例$("div").css("background-color"); 注意：获取样式操作只会返回第一个元素对应的样式值。 隐式迭代： 设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。 3.2 类名class操作 添加样式类 1234//name：需要添加的样式类名，注意参数不要带点.addClass(name);//例子,给所有的div添加one的样式。$(“div”).addClass(“one”); 移除样式类 1234//name:需要移除的样式类名removeClass(“name”);//例子，移除div中one的样式类名$(“div”).removeClass(“one”); 判断是否有某个样式类 1234//name:用于判断的样式类名，返回值为true falsehasClass(name)//例子，判断第一个div是否有one的样式类$(“div”).hasClass(“one”); 切换样式类 1234//name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。toggleClass(name);//例子$(“div”).toggleClass(“one”); 【案例：tab栏切换案例.html】 4. jQuery操作属性4.1 操作attr方法 设置单个属性 123456//第一个参数：需要设置的属性名//第二个参数：对应的属性值attr(name, value);//用法举例$(“img”).attr(“title”,”哎哟，不错哦”);$(“img”).attr(“alt”,“哎哟，不错哦”); 设置多个属性 12345678//参数是一个对象，包含了需要设置的属性名和属性值attr(obj)//用法举例$("img").attr(&#123; title:"哎哟，不错哦", alt:"哎哟，不错哦", style:"opacity:.5"&#125;); 获取属性 12345//传需要获取的属性名称，返回对应的属性值attr(name)//用法举例var oTitle = $("img").attr("title");alert(oTitle); 移除属性 1234//参数：需要移除的属性名，removeAttr(name);//用法举例$("img").removeAttr("title"); 【案例：美女相册.html】 4.2 表单prop操作 在jQuery1.6之后，对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。 1234//设置属性$(“:checked”).prop(“checked”,true);//获取属性$(“:checked”).prop(“checked”);//返回true或者false 【案例：表格全选案例.html】 5. jQuery动画 jquery提供了三组基本动画，这些动画都是标准的、有规律的效果，jquery还提供了自定义动画的功能。【演示动画例子】 5.1 三组基本动画 显示(show)与隐藏(hide)是一组动画：滑入(slideUp)与滑出(slideDown)与切换(slideToggle)，效果与卷帘门类似淡入(fadeIn)与淡出(fadeOut)与切换(fadeToggle) 123456show([speed], [callback]);//speed(可选)：动画的执行时间 //1.如果不传，就没有动画效果。如果是slide和fade系列，会默认为normal //2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐) //3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。//callback(可选):执行完动画后执行的回调函数 【案例：下拉菜单动画版.html】【案例：京东轮播图(呼吸灯).html】 5.2 自定义动画 animate: 自定义动画 12345$(selector).animate(&#123;params&#125;,[speed],[easing],[callback]);// &#123;params&#125;：要执行动画的CSS属性，带数字（必选）// speed：执行动画时长（可选）// easing:执行效果，默认为swing（缓动） 可以是linear（匀速）// callback：动画执行完后立即执行的回调函数（可选） 5.3 动画队列与停止动画 在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行（联想：火车进站）。 1234//stop方法：停止动画效果stop(clearQueue, jumpToEnd);//第一个参数：是否清除队列//第二个参数：是否跳转到最终效果 【案例：手风琴特效】【案例：音乐导航】 6.jQuery节点操作6.1 创建节点123//$(htmlStr)//htmlStr：html格式的字符串$(“&lt;span&gt;这是一个span元素&lt;/span&gt;”); 6.2 添加节点1234//append appendTo//prepend prependTo//before//after 【案例：城市选择案例.html】 6.3 清空节点与删除节点 empty：清空指定节点的所有元素，自身保留(清理门户) 12$(“div”).empty();//清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码）$(“div”).html(“”);//使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。 remove：相比于empty，自身也删除（自杀） 1$(“div”).remove(); 6.4 克隆节点 作用：复制匹配的元素 1234// 复制$(selector)所匹配到的元素（深度复制）//cloneNode(true)// 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。$(selector).clone(); 【案例：微博发布】【案例：弹幕效果】 7. jQuery特殊属性操作7.1 val方法 val方法用于设置和获取表单元素的值，例如input、textarea的值 1234//设置值$("#name").val(“张三”);//获取值$("#name").val(); 【案例：京东搜索.html】 7.2 html方法与text方法 html方法相当于innerHTML text方法相当于innerText 123456789//设置内容$(“div”).html(“&lt;span&gt;这是一段内容&lt;/span&gt;”);//获取内容$(“div”).html()//设置内容$(“div”).text(“&lt;span&gt;这是一段内容&lt;/span&gt;”);//获取内容$(“div”).text() 区别：html方法会识别html标签，text方法会那内容直接当成字符串，并不会识别html标签。 7.3 width方法与height方法 设置或者获取高度 1234//带参数表示设置高度$(“img”).height(200);//不带参数获取高度$(“img”).height(); 获取网页的可视区宽高1234//获取可视区宽度$(window).width();//获取可视区高度$(window).height(); 7.4 scrollTop方法与scrollLeft方法 设置或者获取垂直滚动条的位置 1234//获取页面被卷曲的高度$(window).scrollTop();//获取页面被卷曲的宽度$(window).scrollLeft(); 【案例：仿腾讯固定菜单栏案例】【案例：小火箭返航案例】 7.5 offset方法与position方法 offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。 1234//获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();//获取相对于其最近的有定位的父元素的位置。$(selector).position(); 8. jQuery事件机制 JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。 8.1 jQuery事件发展历程(了解)简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐) 简单事件注册123click(handler) 单击事件mouseenter(handler) 鼠标进入事件mouseleave(handler) 鼠标离开事件 缺点：不能同时注册多个事件 bind方式注册事件 12345//第一个参数：事件类型//第二个参数：事件处理程序$("p").bind("click mouseenter", function()&#123; //事件响应方法&#125;); 缺点：不支持动态事件绑定 delegate注册委托事件 123456// 第一个参数：selector，要绑定事件的元素// 第二个参数：事件类型// 第三个参数：事件处理函数$(".parentBox").delegate("p", "click", function()&#123; //为 .parentBox下面的所有的p标签绑定事件&#125;); 缺点：只能注册委托事件，因此注册时间需要记得方法太多了 on注册事件 8.2 on注册事件(重点) jQuery1.7之后，jQuery用on统一了所有事件的处理方法。 最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。 on注册简单事件12// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on( "click", function() &#123;&#125;); on注册委托事件12// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on( "click",“span”, function() &#123;&#125;); on注册事件的语法：12345// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）// 第四个参数：handler，事件处理函数$(selector).on(events[,selector][,data],handler); 8.3 事件解绑 unbind方式（不用） 12$(selector).unbind(); //解绑所有的事件$(selector).unbind("click"); //解绑指定的事件 undelegate方式（不用） 12$( selector ).undelegate(); //解绑所有的delegate事件$( selector).undelegate( “click” ); //解绑所有的click事件 off方式（推荐） 1234// 解绑匹配元素的所有事件$(selector).off();// 解绑匹配元素的所有click事件$(selector).off("click"); 8.4 触发事件12$(selector).click(); //触发 click事件$(selector).trigger("click"); 8.5 jQuery事件对象jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。12345678910//screenX和screenY 对应屏幕最左上角的值//clientX和clientY 距离页面左上角的位置（忽视滚动条）//pageX和pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）//event.keyCode 按下的键盘代码//event.data 存储绑定事件时传递的附加数据//event.stopPropagation() 阻止事件冒泡行为//event.preventDefault() 阻止浏览器默认行为//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。 【案例：钢琴版导航（加强）.html】 9 jQuery补充知识点9.1 链式编程 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。 1end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。 【案例：五角星评分案例.html】 9.2 each方法 jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。 作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数123// 参数一表示当前元素在所有匹配元素中的索引号// 参数二表示当前元素（DOM对象）$(selector).each(function(index,element)&#123;&#125;); 【案例：不同的透明度.html】 9.3 多库共存 jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权. 1var c = $.noConflict();//释放$的控制权,并且把$的能力给了c 10 插件10.1 常用插件 插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。 jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。 插件 jquery.color.js animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。 使用插件的步骤1231. 引入jQuery文件2. 引入插件（如果有用到css的话，需要引入css）3. 使用插件 jquery.lazyload.js 懒加载插件 10.2 jquery.ui.js插件jQueryUI专指由jQuery官方维护的UI方向的插件。 官方API：http://api.jqueryui.com/category/all/ 其他教程：jQueryUI教程 基本使用:12341. 引入jQueryUI的样式文件2. 引入jQuery3. 引入jQueryUI的js文件4. 使用jQueryUI功能 使用jquery.ui.js实现新闻模块的案例 10.3 制作jquery插件 原理：jquery插件其实说白了就是给jquery对象增加一个新的方法，让jquery对象拥有某一个功能。 12//通过给$.fn添加方法就能够扩展jquery对象$.fn. pluginName = function() &#123;&#125;;]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调试工具的使用]]></title>
    <url>%2F2015%2F06%2F07%2F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[开启调试窗口windows 平台: f12 调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试 调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束 设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint) 利用 watch 监视窗口可以查看对象成员]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2015%2F06%2F07%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript数据类型JavaScript中的数据类型分为两种：基本数据类型和复杂数据类型。 基本数据类型 number string boolean undefined null 复杂数据类型 object 如何判断一个变量的数据类型typeof关键字，可以用来返回变量对应的数据类型。]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js基础</tag>
      </tags>
  </entry>
</search>
